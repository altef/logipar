<?php
/**
 * Generated by Haxe 4.0.0-rc.2+77068e10c
 */

use \php\Boot;

class BinaryNode extends \UnaryNode {
	/**
	 * @var \Node
	 */
	public $left;

	/**
	 * @param \Types $type
	 * 
	 * @return void
	 */
	public function __construct ($type) {
		#src/LogicString.hx:59: lines 59-78
		parent::__construct($type);
	}

	/**
	 * @return string
	 */
	public function toString () {
		#src/LogicString.hx:62: characters 10-19
		$_g = $this->type;
		if ($_g->index === 3) {
			#src/LogicString.hx:63: characters 22-23
			$o = $_g->params[0];
			#src/LogicString.hx:64: characters 5-17
			$op = "";
			#src/LogicString.hx:65: lines 65-72
			$__hx__switch = ($o->index);
			if ($__hx__switch === 0) {
				#src/LogicString.hx:67: characters 7-17
				$op = "AND";
			} else if ($__hx__switch === 1) {
				#src/LogicString.hx:69: characters 7-16
				$op = "OR";
			} else if ($__hx__switch === 2) {
				#src/LogicString.hx:71: characters 7-17
				$op = "XOR";
			}
			#src/LogicString.hx:73: characters 5-63
			return "(" . (\Std::string($this->left)??'null') . " " . ($op??'null') . " " . (\Std::string($this->right)??'null') . ")";
		} else {
			#src/LogicString.hx:75: characters 5-35
			return "[INVALID BINARY NODE]";
		}
	}

	public function __toString() {
		return $this->toString();
	}
}

Boot::registerClass(BinaryNode::class, 'BinaryNode');
