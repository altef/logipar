<?php
/**
 * Generated by Haxe 4.0.0-rc.2+77068e10c
 */

namespace buddy;

use \php\Boot;

class ShouldIterable extends Should {

	/**
	 * @param object $value
	 * 
	 * @return ShouldIterable
	 */
	static public function should ($value) {
		#C:\HaxeToolkit\haxe\lib\buddy/2,10,2/buddy/Should.hx:244: characters 3-38
		return new ShouldIterable($value);
	}

	/**
	 * @param object $value
	 * @param bool $inverse
	 * 
	 * @return void
	 */
	public function __construct ($value, $inverse = false) {
		#C:\HaxeToolkit\haxe\lib\buddy/2,10,2/buddy/Should.hx:249: characters 3-24
		if ($inverse === null) {
			$inverse = false;
		}
		parent::__construct($value, $inverse);
	}

	/**
	 * @param mixed $o
	 * @param object $p
	 * 
	 * @return void
	 */
	public function contain ($o, $p = null) {
		#C:\HaxeToolkit\haxe\lib\buddy/2,10,2/buddy/Should.hx:259: lines 259-262
		$this->test(\Lambda::exists($this->value, function ($el)  use (&$o) {
			#C:\HaxeToolkit\haxe\lib\buddy/2,10,2/buddy/Should.hx:259: characters 42-56
			return Boot::equal($el, $o);
		}), $p, "Expected " . ($this->quote($this->value)??'null') . " to contain " . ($this->quote($o)??'null'), "Expected " . ($this->quote($this->value)??'null') . " not to contain " . ($this->quote($o)??'null'));
	}

	/**
	 * Test if iterable contains all of the following values.
	 * 
	 * @param object $values
	 * @param object $p
	 * 
	 * @return void
	 */
	public function containAll ($values, $p = null) {
		#C:\HaxeToolkit\haxe\lib\buddy/2,10,2/buddy/Should.hx:270: characters 3-19
		$expr = true;
		#C:\HaxeToolkit\haxe\lib\buddy/2,10,2/buddy/Should.hx:273: characters 13-19
		$a = $values->iterator();
		while ($a->hasNext()) {
			unset($a1);
			#C:\HaxeToolkit\haxe\lib\buddy/2,10,2/buddy/Should.hx:273: lines 273-280
			$a1 = $a->next();
			#C:\HaxeToolkit\haxe\lib\buddy/2,10,2/buddy/Should.hx:275: lines 275-279
			if (!\Lambda::exists($this->value, function ($v)  use (&$a1) {
				#C:\HaxeToolkit\haxe\lib\buddy/2,10,2/buddy/Should.hx:275: characters 36-49
				return Boot::equal($v, $a1);
			})) {
				#C:\HaxeToolkit\haxe\lib\buddy/2,10,2/buddy/Should.hx:277: characters 5-17
				$expr = false;
				#C:\HaxeToolkit\haxe\lib\buddy/2,10,2/buddy/Should.hx:278: characters 5-10
				break;
			}
		}

		#C:\HaxeToolkit\haxe\lib\buddy/2,10,2/buddy/Should.hx:282: lines 282-285
		$this->test($expr, $p, "Expected " . ($this->quote($this->value)??'null') . " to contain all of " . ($this->quote($values)??'null'), "Expected " . ($this->quote($this->value)??'null') . " not to contain all of " . ($this->quote($values)??'null'));
	}

	/**
	 * Test if iterable contains exactly the following values and in the same iteration order.
	 * 
	 * @param object $values
	 * @param object $p
	 * 
	 * @return void
	 */
	public function containExactly ($values, $p = null) {
		#C:\HaxeToolkit\haxe\lib\buddy/2,10,2/buddy/Should.hx:293: characters 3-28
		$a = $this->value->iterator();
		#C:\HaxeToolkit\haxe\lib\buddy/2,10,2/buddy/Should.hx:294: characters 3-29
		$b = $values->iterator();
		#C:\HaxeToolkit\haxe\lib\buddy/2,10,2/buddy/Should.hx:295: characters 3-19
		$expr = true;
		#C:\HaxeToolkit\haxe\lib\buddy/2,10,2/buddy/Should.hx:297: lines 297-304
		while ($a->hasNext() || $b->hasNext()) {
			#C:\HaxeToolkit\haxe\lib\buddy/2,10,2/buddy/Should.hx:299: lines 299-303
			if (!Boot::equal($a->next(), $b->next())) {
				#C:\HaxeToolkit\haxe\lib\buddy/2,10,2/buddy/Should.hx:301: characters 5-17
				$expr = false;
				#C:\HaxeToolkit\haxe\lib\buddy/2,10,2/buddy/Should.hx:302: characters 5-10
				break;
			}
		}
		#C:\HaxeToolkit\haxe\lib\buddy/2,10,2/buddy/Should.hx:306: lines 306-309
		$this->test($expr, $p, "Expected " . ($this->quote($this->value)??'null') . " to contain exactly " . ($this->quote($values)??'null'), "Expected " . ($this->quote($this->value)??'null') . " not to contain exactly " . ($this->quote($values)??'null'));
	}

	/**
	 * @return ShouldIterable
	 */
	public function get_not () {
		#C:\HaxeToolkit\haxe\lib\buddy/2,10,2/buddy/Should.hx:253: characters 31-76
		return new ShouldIterable($this->value, !$this->inverse);
	}
}

Boot::registerClass(ShouldIterable::class, 'buddy.ShouldIterable');
Boot::registerGetters('buddy\\ShouldIterable', [
	'not' => true
]);
