<?php
/**
 * Generated by Haxe 4.0.0-rc.2+77068e10c
 */

use \php\_Boot\HxAnon;
use \php\Boot;
use \haxe\Log;
use \haxe\ds\GenericCell;
use \haxe\ds\EnumValueMap;
use \php\_Boot\HxException;
use \haxe\ds\GenericStack;

class LogicString {
	/**
	 * @var bool
	 */
	public $caseSensitive;
	/**
	 * @var \Node
	 */
	public $logictree;
	/**
	 * @var \Array_hx
	 */
	public $quotations;
	/**
	 * @var EnumValueMap
	 */
	public $syntax;

	/**
	 * @param EnumValueMap $custom_syntax
	 * 
	 * @return void
	 */
	public function __construct ($custom_syntax) {
		#src/LogicString.hx:112: characters 34-38
		$this->caseSensitive = true;
		#src/LogicString.hx:111: characters 26-36
		$this->quotations = \Array_hx::wrap([
			"\"",
			"'",
		]);
		#src/LogicString.hx:102: lines 102-109
		$_g = new EnumValueMap();
		$_g->set(\Syntax::AND(), "AND");
		$_g->set(\Syntax::OR(), "OR");
		$_g->set(\Syntax::XOR(), "XOR");
		$_g->set(\Syntax::NOT(), "NOT");
		$_g->set(\Syntax::OPEN(), "(");
		$_g->set(\Syntax::CLOSE(), ")");
		$this->syntax = $_g;
		#src/LogicString.hx:118: characters 14-34
		$key = $custom_syntax->keys();
		while ($key->hasNext()) {
			#src/LogicString.hx:118: lines 118-120
			$key1 = $key->next();
			#src/LogicString.hx:119: lines 119-120
			if ($this->syntax->exists($key1)) {
				#src/LogicString.hx:120: characters 5-44
				$this->syntax->set($key1, $custom_syntax->get($key1));
			}
		}
	}

	/**
	 * @param \Closure $f
	 * 
	 * @return \Closure
	 */
	public function filterFunction ($f) {
		#src/LogicString.hx:144: characters 3-28
		$enclosed = $this->logictree;
		#src/LogicString.hx:145: lines 145-148
		return function ($a)  use (&$f, &$enclosed) {
			#src/LogicString.hx:147: characters 4-31
			return $enclosed->check($a, $f);
		};
	}

	/**
	 * @param string $logic_string
	 * 
	 * @return mixed
	 */
	public function parse ($logic_string) {
		#src/LogicString.hx:126: characters 3-8
		(Log::$trace)($logic_string, new HxAnon([
			"fileName" => "src/LogicString.hx",
			"lineNumber" => 126,
			"className" => "LogicString",
			"methodName" => "parse",
		]));
		#src/LogicString.hx:127: characters 3-39
		$tokens = $this->tokenize($logic_string);
		#src/LogicString.hx:128: characters 3-8
		(Log::$trace)($tokens, new HxAnon([
			"fileName" => "src/LogicString.hx",
			"lineNumber" => 128,
			"className" => "LogicString",
			"methodName" => "parse",
		]));
		#src/LogicString.hx:129: characters 3-31
		$types = $this->typeize($tokens);
		#src/LogicString.hx:130: characters 3-8
		(Log::$trace)($types, new HxAnon([
			"fileName" => "src/LogicString.hx",
			"lineNumber" => 130,
			"className" => "LogicString",
			"methodName" => "parse",
		]));
		#src/LogicString.hx:131: characters 3-36
		$reversepolish = $this->shunt($types);
		#src/LogicString.hx:132: characters 3-8
		(Log::$trace)($reversepolish, new HxAnon([
			"fileName" => "src/LogicString.hx",
			"lineNumber" => 132,
			"className" => "LogicString",
			"methodName" => "parse",
		]));
		#src/LogicString.hx:133: characters 3-34
		$tree = $this->tree($reversepolish);
		#src/LogicString.hx:134: characters 3-24
		$this->logictree = $tree;
		#src/LogicString.hx:135: characters 3-14
		return $tree;
	}

	/**
	 * @param \Array_hx $tokens
	 * 
	 * @return \Array_hx
	 */
	public function shunt ($tokens) {
		#src/LogicString.hx:180: characters 3-48
		$output = new \Array_hx();
		#src/LogicString.hx:181: characters 3-65
		$operators = new GenericStack();
		#src/LogicString.hx:182: characters 3-8
		(Log::$trace)("Reverse polish:", new HxAnon([
			"fileName" => "src/LogicString.hx",
			"lineNumber" => 182,
			"className" => "LogicString",
			"methodName" => "shunt",
		]));
		#src/LogicString.hx:183: lines 183-221
		$_g = 0;
		$_g1 = $tokens->length;
		while ($_g < $_g1) {
			$i = $_g++;
			#src/LogicString.hx:184: characters 4-9
			(Log::$trace)(":::", new HxAnon([
				"fileName" => "src/LogicString.hx",
				"lineNumber" => 184,
				"className" => "LogicString",
				"methodName" => "shunt",
			]));
			#src/LogicString.hx:185: characters 4-9
			(Log::$trace)($output, new HxAnon([
				"fileName" => "src/LogicString.hx",
				"lineNumber" => 185,
				"className" => "LogicString",
				"methodName" => "shunt",
			]));
			#src/LogicString.hx:186: characters 4-9
			(Log::$trace)($operators, new HxAnon([
				"fileName" => "src/LogicString.hx",
				"lineNumber" => 186,
				"className" => "LogicString",
				"methodName" => "shunt",
			]));
			#src/LogicString.hx:187: characters 4-26
			$token = ($tokens->arr[$i] ?? null);
			#src/LogicString.hx:188: characters 11-21
			$__hx__switch = ($token->type->index);
			if ($__hx__switch === 4) {
				#src/LogicString.hx:192: characters 6-26
				$operators->head = new GenericCell($token, $operators->head);
			} else if ($__hx__switch === 5) {
				#src/LogicString.hx:194: lines 194-201
				while (true) {
					#src/LogicString.hx:195: characters 16-31
					$k = $operators->head;
					$op = null;
					if ($k === null) {
						$op = null;
					} else {
						$operators->head = $k->next;
						$op = $k->elt;
					}
					#src/LogicString.hx:195: characters 7-32
					$op1 = $op;
					#src/LogicString.hx:196: lines 196-197
					if ($op1->type === \Syntax::OPEN()) {
						#src/LogicString.hx:197: characters 8-13
						break;
					}
					#src/LogicString.hx:198: lines 198-199
					if ($operators->head === null) {
						#src/LogicString.hx:199: characters 8-13
						throw new HxException("Mismatched parentheses.");
					}
					#src/LogicString.hx:200: characters 7-22
					$output->arr[$output->length] = $op1;
					++$output->length;

				}
			} else if ($__hx__switch === 6) {
				#src/LogicString.hx:190: characters 6-24
				$output->arr[$output->length] = $token;
				++$output->length;
			} else {
				#src/LogicString.hx:203: lines 203-217
				while ($operators->head !== null) {
					#src/LogicString.hx:207: characters 7-36
					$prev = ($operators->head === null ? null : $operators->head->elt);
					#src/LogicString.hx:209: lines 209-211
					if ($prev->type === \Syntax::OPEN()) {
						#src/LogicString.hx:210: characters 8-13
						break;
					}
					#src/LogicString.hx:213: lines 213-214
					if ($prev->precedence() <= $token->precedence()) {
						#src/LogicString.hx:214: characters 8-13
						break;
					}
					#src/LogicString.hx:216: characters 19-34
					$k1 = $operators->head;
					$x = null;
					if ($k1 === null) {
						$x = null;
					} else {
						$operators->head = $k1->next;
						$x = $k1->elt;
					}
					#src/LogicString.hx:216: characters 7-35
					$output->arr[$output->length] = $x;
					++$output->length;

				}
				#src/LogicString.hx:218: characters 6-26
				$operators->head = new GenericCell($token, $operators->head);
			}
		}

		#src/LogicString.hx:223: lines 223-228
		while ($operators->head !== null) {
			#src/LogicString.hx:224: characters 12-27
			$k2 = $operators->head;
			$o = null;
			if ($k2 === null) {
				$o = null;
			} else {
				$operators->head = $k2->next;
				$o = $k2->elt;
			}
			#src/LogicString.hx:224: characters 4-28
			$o1 = $o;
			#src/LogicString.hx:225: lines 225-226
			if ($o1->type === \Syntax::OPEN()) {
				#src/LogicString.hx:226: characters 5-10
				throw new HxException("Mismatched parentheses.");
			}
			#src/LogicString.hx:227: characters 4-18
			$output->arr[$output->length] = $o1;
			++$output->length;

		}
		#src/LogicString.hx:229: characters 3-16
		return $output;
	}

	/**
	 * @param \Closure $f
	 * 
	 * @return string
	 */
	public function stringify ($f) {
		#src/LogicString.hx:140: characters 3-34
		return $this->logictree->fancyString($f);
	}

	/**
	 * @param string $s
	 * 
	 * @return string
	 */
	public function tentativelyLower ($s) {
		#src/LogicString.hx:234: characters 10-57
		if ($this->caseSensitive) {
			#src/LogicString.hx:234: characters 26-27
			return $s;
		} else {
			#src/LogicString.hx:234: characters 30-57
			return mb_strtolower(\Std::string($s));
		}
	}

	/**
	 * @param string $token
	 * 
	 * @return \Token
	 */
	public function tokenType ($token) {
		#src/LogicString.hx:280: characters 14-27
		$key = $this->syntax->keys();
		while ($key->hasNext()) {
			#src/LogicString.hx:280: lines 280-283
			$key1 = $key->next();
			#src/LogicString.hx:281: lines 281-282
			if ($this->tentativelyLower($token) === $this->tentativelyLower($this->syntax->get($key1))) {
				#src/LogicString.hx:282: characters 5-26
				return new \Token($key1);
			}
		}

		#src/LogicString.hx:284: characters 3-42
		return new \Token(\Syntax::LITERAL(), $token);
	}

	/**
	 * @param string $str
	 * 
	 * @return \Array_hx
	 */
	public function tokenize ($str) {
		#src/LogicString.hx:240: characters 3-33
		$tokens = new \Array_hx();
		#src/LogicString.hx:241: characters 28-66
		$_g = new \Array_hx();
		#src/LogicString.hx:241: characters 38-44
		$x = $this->syntax->iterator();
		while ($x->hasNext()) {
			#src/LogicString.hx:241: characters 29-65
			$x1 = $x->next();
			#src/LogicString.hx:241: characters 46-65
			$x2 = $this->tentativelyLower($x1);
			$_g->arr[$_g->length] = $x2;
			++$_g->length;
		}

		#src/LogicString.hx:241: characters 3-67
		$keys = $_g;
		#src/LogicString.hx:242: characters 3-31
		$quotation = null;
		#src/LogicString.hx:244: characters 3-27
		$current = "";
		#src/LogicString.hx:245: lines 245-271
		$_g1 = 0;
		$_g2 = mb_strlen($str);
		while ($_g1 < $_g2) {
			$i = $_g1++;
			#src/LogicString.hx:246: characters 4-26
			$c = ($i < 0 ? "" : mb_substr($str, $i, 1));
			#src/LogicString.hx:247: lines 247-270
			if ($keys->indexOf($this->tentativelyLower($c)) === -1) {
				#src/LogicString.hx:250: lines 250-256
				if ($this->quotations->indexOf($c) !== -1) {
					#src/LogicString.hx:251: lines 251-255
					if ($quotation === null) {
						#src/LogicString.hx:252: characters 7-20
						$quotation = $c;
					} else if ($quotation === $c) {
						#src/LogicString.hx:254: characters 7-23
						$quotation = null;
					}
				}
				#src/LogicString.hx:258: lines 258-263
				if (\StringTools::isSpace($c, 0) && ($quotation === null)) {
					#src/LogicString.hx:259: lines 259-260
					if (mb_strlen($current) > 0) {
						#src/LogicString.hx:260: characters 7-27
						$tokens->arr[$tokens->length] = $current;
						++$tokens->length;
					}
					#src/LogicString.hx:261: characters 6-18
					$current = "";
				} else {
					#src/LogicString.hx:263: characters 6-18
					$current = ($current??'null') . ($c??'null');
				}
			} else {
				#src/LogicString.hx:265: lines 265-267
				if (mb_strlen($current) > 0) {
					#src/LogicString.hx:266: characters 6-26
					$tokens->arr[$tokens->length] = $current;
					++$tokens->length;
				}
				#src/LogicString.hx:268: characters 5-17
				$current = "";
				#src/LogicString.hx:269: characters 5-19
				$tokens->arr[$tokens->length] = $c;
				++$tokens->length;

			}
		}

		#src/LogicString.hx:272: lines 272-273
		if (mb_strlen(trim($current)) > 0) {
			#src/LogicString.hx:273: characters 4-31
			$x3 = trim($current);
			$tokens->arr[$tokens->length] = $x3;
			++$tokens->length;
		}
		#src/LogicString.hx:274: characters 3-16
		return $tokens;
	}

	/**
	 * @param \Array_hx $tokens
	 * 
	 * @return \Node
	 */
	public function tree ($tokens) {
		#src/LogicString.hx:152: characters 3-59
		$stack = new GenericStack();
		#src/LogicString.hx:153: lines 153-169
		$_g = 0;
		$_g1 = $tokens->length;
		while ($_g < $_g1) {
			$i = $_g++;
			#src/LogicString.hx:154: characters 4-26
			$token = ($tokens->arr[$i] ?? null);
			#src/LogicString.hx:155: characters 4-28
			$n = new \Node($token);
			#src/LogicString.hx:157: lines 157-167
			if ($token->type !== \Syntax::LITERAL()) {
				#src/LogicString.hx:158: lines 158-159
				if ($stack->head === null) {
					#src/LogicString.hx:159: characters 6-11
					throw new HxException("An '" . ($this->syntax->get($token->type)??'null') . "' is missing a value to operate on (on its right).");
				}
				#src/LogicString.hx:160: characters 15-26
				$k = $stack->head;
				$tmp = null;
				if ($k === null) {
					$tmp = null;
				} else {
					$stack->head = $k->next;
					$tmp = $k->elt;
				}
				#src/LogicString.hx:160: characters 5-26
				$n->right = $tmp;
				#src/LogicString.hx:161: lines 161-165
				if ($token->type !== \Syntax::NOT()) {
					#src/LogicString.hx:162: lines 162-163
					if ($stack->head === null) {
						#src/LogicString.hx:163: characters 7-12
						throw new HxException("An '" . ($this->syntax->get($token->type)??'null') . "' is missing a value to operate on (on its left).");
					}
					#src/LogicString.hx:164: characters 15-26
					$k1 = $stack->head;
					$tmp1 = null;
					if ($k1 === null) {
						$tmp1 = null;
					} else {
						$stack->head = $k1->next;
						$tmp1 = $k1->elt;
					}
					#src/LogicString.hx:164: characters 6-26
					$n->left = $tmp1;
				}
			}
			#src/LogicString.hx:168: characters 4-16
			$stack->head = new GenericCell($n, $stack->head);
		}

		#src/LogicString.hx:170: characters 19-30
		$k2 = $stack->head;
		$parsetree = null;
		if ($k2 === null) {
			$parsetree = null;
		} else {
			$stack->head = $k2->next;
			$parsetree = $k2->elt;
		}
		#src/LogicString.hx:170: characters 3-31
		$parsetree1 = $parsetree;
		#src/LogicString.hx:171: lines 171-174
		if ($stack->head !== null) {
			#src/LogicString.hx:172: characters 4-9
			(Log::$trace)($stack, new HxAnon([
				"fileName" => "src/LogicString.hx",
				"lineNumber" => 172,
				"className" => "LogicString",
				"methodName" => "tree",
			]));
			#src/LogicString.hx:173: characters 4-9
			throw new HxException("I expected the stack to be empty but it's not!");
		}
		#src/LogicString.hx:175: characters 3-19
		return $parsetree1;
	}

	/**
	 * @param \Array_hx $tokens
	 * 
	 * @return \Array_hx
	 */
	public function typeize ($tokens) {
		#src/LogicString.hx:289: characters 10-65
		$_g = new \Array_hx();
		#src/LogicString.hx:289: characters 11-64
		$_g1 = 0;
		$_g2 = $tokens->length;
		while ($_g1 < $_g2) {
			$i = $_g1++;
			#src/LogicString.hx:289: characters 39-64
			$x = $this->tokenType(($tokens->arr[$i] ?? null));
			$_g->arr[$_g->length] = $x;
			++$_g->length;

		}

		#src/LogicString.hx:289: characters 10-65
		return $_g;
	}
}

Boot::registerClass(LogicString::class, 'LogicString');
