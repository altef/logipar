<?php
/**
 * Generated by Haxe 4.0.0-rc.2+77068e10c
 */

namespace promhx;

use \php\_Boot\HxAnon;
use \haxe\ds\Option;
use \php\Boot;
use \haxe\CallStack;
use \promhx\base\EventLoop;
use \promhx\base\AsyncBase;
use \php\_Boot\HxException;

class Stream extends AsyncBase {
	/**
	 * @var bool
	 */
	public $_end;
	/**
	 * @var Promise
	 */
	public $_end_promise;
	/**
	 * @var bool
	 */
	public $_pause;
	/**
	 * @var Deferred
	 */
	public $deferred;

	/**
	 * Concatenates all the streams in the iterable argument to a single stream.  See
	 * the [concat] instance method.
	 * 
	 * @param object $itb
	 * 
	 * @return Stream
	 */
	static public function concatAll ($itb) {
		#C:\HaxeToolkit\haxe\lib\promhx/1,1,0/src/main/promhx/Stream.hx:123: characters 9-59
		$ret = new Stream(null);
		#C:\HaxeToolkit\haxe\lib\promhx/1,1,0/src/main/promhx/Stream.hx:124: characters 19-22
		$i = $itb->iterator();
		while ($i->hasNext()) {
			#C:\HaxeToolkit\haxe\lib\promhx/1,1,0/src/main/promhx/Stream.hx:124: characters 9-37
			$i1 = $i->next();
			#C:\HaxeToolkit\haxe\lib\promhx/1,1,0/src/main/promhx/Stream.hx:124: characters 24-37
			$ret->concat($i1);
		}

		#C:\HaxeToolkit\haxe\lib\promhx/1,1,0/src/main/promhx/Stream.hx:125: characters 9-19
		return $ret;
	}

	/**
	 * Creates a stream from the iterable [itb] that will immediately update
	 * for each value, and then end.
	 * 
	 * @param object $itb
	 * 
	 * @return Stream
	 */
	static public function foreach ($itb) {
		#C:\HaxeToolkit\haxe\lib\promhx/1,1,0/src/main/promhx/Stream.hx:71: characters 9-57
		$s = new Stream(null);
		#C:\HaxeToolkit\haxe\lib\promhx/1,1,0/src/main/promhx/Stream.hx:72: characters 19-22
		$i = $itb->iterator();
		while ($i->hasNext()) {
			#C:\HaxeToolkit\haxe\lib\promhx/1,1,0/src/main/promhx/Stream.hx:72: characters 9-42
			$i1 = $i->next();
			#C:\HaxeToolkit\haxe\lib\promhx/1,1,0/src/main/promhx/Stream.hx:72: characters 24-42
			$s->handleResolve($i1);
		}

		#C:\HaxeToolkit\haxe\lib\promhx/1,1,0/src/main/promhx/Stream.hx:73: characters 9-16
		$s->end();
		#C:\HaxeToolkit\haxe\lib\promhx/1,1,0/src/main/promhx/Stream.hx:74: characters 9-17
		return $s;
	}

	/**
	 * Merges all the streams in the iterable argument to a single stream.  See
	 * the [merge] instance method.
	 * 
	 * @param object $itb
	 * 
	 * @return Stream
	 */
	static public function mergeAll ($itb) {
		#C:\HaxeToolkit\haxe\lib\promhx/1,1,0/src/main/promhx/Stream.hx:133: characters 9-59
		$ret = new Stream(null);
		#C:\HaxeToolkit\haxe\lib\promhx/1,1,0/src/main/promhx/Stream.hx:134: characters 19-22
		$i = $itb->iterator();
		while ($i->hasNext()) {
			#C:\HaxeToolkit\haxe\lib\promhx/1,1,0/src/main/promhx/Stream.hx:134: characters 9-36
			$i1 = $i->next();
			#C:\HaxeToolkit\haxe\lib\promhx/1,1,0/src/main/promhx/Stream.hx:134: characters 24-36
			$ret->merge($i1);
		}

		#C:\HaxeToolkit\haxe\lib\promhx/1,1,0/src/main/promhx/Stream.hx:135: characters 9-19
		return $ret;
	}

	/**
	 * Converts any value to a resolved Stream
	 * 
	 * @param mixed $_val
	 * 
	 * @return Stream
	 */
	static public function stream ($_val) {
		#C:\HaxeToolkit\haxe\lib\promhx/1,1,0/src/main/promhx/Stream.hx:267: characters 9-59
		$ret = new Stream(null);
		#C:\HaxeToolkit\haxe\lib\promhx/1,1,0/src/main/promhx/Stream.hx:268: characters 9-32
		$ret->handleResolve($_val);
		#C:\HaxeToolkit\haxe\lib\promhx/1,1,0/src/main/promhx/Stream.hx:269: characters 9-19
		return $ret;
	}

	/**
	 * Transforms an iterable of streams into a single stream which resolves
	 * to an array of values.
	 * 
	 * @param object $itb
	 * 
	 * @return Stream
	 */
	static public function wheneverAll ($itb) {
		#C:\HaxeToolkit\haxe\lib\promhx/1,1,0/src/main/promhx/Stream.hx:113: characters 9-66
		$ret = new Stream(null);
		#C:\HaxeToolkit\haxe\lib\promhx/1,1,0/src/main/promhx/Stream.hx:114: characters 9-36
		$all = $itb;
		$next = $ret;
		$cthen = function ($arr, $current, $v)  use (&$next, &$all) {
			if (($arr->length === 0) || AsyncBase::allFulfilled($arr)) {
				$_g = new \Array_hx();
				$a = $all->iterator();
				while ($a->hasNext()) {
					$a1 = $a->next();
					$_g->arr[$_g->length] = ($a1 === $current ? $v : $a1->_val);
					++$_g->length;
				}

				$vals = $_g;
				$next->handleResolve($vals);
			}
			return;
		};
		$a2 = $all->iterator();
		while ($a2->hasNext()) {
			unset($f, $arr1, $current1);
			$a3 = $a2->next();
			$_this = $a3->_update;
			$f = $cthen;
			$_g1 = new \Array_hx();
			$a21 = $all->iterator();
			while ($a21->hasNext()) {
				$a22 = $a21->next();
				if ($a22 !== $a3) {
					$_g1->arr[$_g1->length] = $a22;
					++$_g1->length;
				}
			}

			$arr1 = $_g1;
			$current1 = $a3;
			$x = function ($v1)  use (&$f, &$arr1, &$current1) {
				$f($arr1, $current1, $v1);
				return;
			};
			$_this->arr[$_this->length] = new HxAnon([
				"async" => $next,
				"linkf" => $x,
			]);
			++$_this->length;
		}

		if (AsyncBase::allFulfilled($all)) {
			$_g2 = new \Array_hx();
			$a4 = $all->iterator();
			while ($a4->hasNext()) {
				$a5 = $a4->next();
				$_g2->arr[$_g2->length] = $a5->_val;
				++$_g2->length;
			}

			$next->handleResolve($_g2);
		}

		#C:\HaxeToolkit\haxe\lib\promhx/1,1,0/src/main/promhx/Stream.hx:115: characters 9-19
		return $ret;
	}

	/**
	 * @param Deferred $d
	 * 
	 * @return void
	 */
	public function __construct ($d = null) {
		#C:\HaxeToolkit\haxe\lib\promhx/1,1,0/src/main/promhx/Stream.hx:20: characters 9-37
		parent::__construct($d);
		#C:\HaxeToolkit\haxe\lib\promhx/1,1,0/src/main/promhx/Stream.hx:21: characters 9-48
		$this->_end_promise = new Promise();
	}

	/**
	 * Creates a new stream that updates with the values from the current
	 * stream until the stream ends, and then takes values from the next stream
	 * [s] until that stream ends.
	 * 
	 * @param Stream $s
	 * 
	 * @return Stream
	 */
	public function concat ($s) {
		#C:\HaxeToolkit\haxe\lib\promhx/1,1,0/src/main/promhx/Stream.hx:227: characters 9-59
		$ret = new Stream(null);
		#C:\HaxeToolkit\haxe\lib\promhx/1,1,0/src/main/promhx/Stream.hx:228: lines 228-231
		$_this = $this->_update;
		$_this->arr[$_this->length] = new HxAnon([
			"async" => $ret,
			"linkf" => Boot::getInstanceClosure($ret, 'handleResolve'),
		]);
		++$_this->length;

		#C:\HaxeToolkit\haxe\lib\promhx/1,1,0/src/main/promhx/Stream.hx:232: characters 9-71
		AsyncBase::immediateLinkUpdate($this, $ret, function ($x) {
			#C:\HaxeToolkit\haxe\lib\promhx/1,1,0/src/main/promhx/Stream.hx:232: characters 62-70
			return $x;
		});
		#C:\HaxeToolkit\haxe\lib\promhx/1,1,0/src/main/promhx/Stream.hx:233: lines 233-241
		$this->_end_promise->then(function ($_)  use (&$ret, &$s) {
			#C:\HaxeToolkit\haxe\lib\promhx/1,1,0/src/main/promhx/Stream.hx:234: lines 234-237
			$s->pipe(function ($x1)  use (&$ret) {
				#C:\HaxeToolkit\haxe\lib\promhx/1,1,0/src/main/promhx/Stream.hx:235: characters 17-37
				$ret->handleResolve($x1);
				#C:\HaxeToolkit\haxe\lib\promhx/1,1,0/src/main/promhx/Stream.hx:236: characters 17-27
				return $ret;
			});
			#C:\HaxeToolkit\haxe\lib\promhx/1,1,0/src/main/promhx/Stream.hx:238: lines 238-240
			$s->_end_promise->then(function ($_1)  use (&$ret) {
				#C:\HaxeToolkit\haxe\lib\promhx/1,1,0/src/main/promhx/Stream.hx:239: characters 17-26
				$ret->end();
			});
		});
		#C:\HaxeToolkit\haxe\lib\promhx/1,1,0/src/main/promhx/Stream.hx:242: characters 9-19
		return $ret;
	}

	/**
	 * @param Stream $str
	 * 
	 * @return bool
	 */
	public function detachStream ($str) {
		#C:\HaxeToolkit\haxe\lib\promhx/1,1,0/src/main/promhx/Stream.hx:92: characters 9-27
		$filtered = new \Array_hx();
		#C:\HaxeToolkit\haxe\lib\promhx/1,1,0/src/main/promhx/Stream.hx:93: characters 9-29
		$removed = false;
		#C:\HaxeToolkit\haxe\lib\promhx/1,1,0/src/main/promhx/Stream.hx:94: lines 94-103
		$_g = 0;
		$_g1 = $this->_update;
		while ($_g < $_g1->length) {
			#C:\HaxeToolkit\haxe\lib\promhx/1,1,0/src/main/promhx/Stream.hx:94: characters 14-15
			$u = ($_g1->arr[$_g] ?? null);
			#C:\HaxeToolkit\haxe\lib\promhx/1,1,0/src/main/promhx/Stream.hx:94: lines 94-103
			++$_g;
			#C:\HaxeToolkit\haxe\lib\promhx/1,1,0/src/main/promhx/Stream.hx:95: lines 95-102
			if ($u->async === $str) {
				#C:\HaxeToolkit\haxe\lib\promhx/1,1,0/src/main/promhx/Stream.hx:97: lines 97-99
				$_this = $this->_end_promise->_update;
				$f = function ($x)  use (&$str) {
					#C:\HaxeToolkit\haxe\lib\promhx/1,1,0/src/main/promhx/Stream.hx:98: characters 21-55
					return $x->async !== $str->_end_promise;
				};
				#C:\HaxeToolkit\haxe\lib\promhx/1,1,0/src/main/promhx/Stream.hx:97: lines 97-99
				$result = [];
				$collection = $_this->arr;
				foreach ($collection as $key => $value) {
					if ($f($value)) {
						$result[] = $value;
					}
				}

				$tmp = \Array_hx::wrap($result);
				$this->_end_promise->_update = $tmp;
				#C:\HaxeToolkit\haxe\lib\promhx/1,1,0/src/main/promhx/Stream.hx:100: characters 17-31
				$removed = true;
			} else {
				#C:\HaxeToolkit\haxe\lib\promhx/1,1,0/src/main/promhx/Stream.hx:102: characters 18-34
				$filtered->arr[$filtered->length] = $u;
				++$filtered->length;
			}
		}

		#C:\HaxeToolkit\haxe\lib\promhx/1,1,0/src/main/promhx/Stream.hx:104: characters 9-27
		$this->_update = $filtered;
		#C:\HaxeToolkit\haxe\lib\promhx/1,1,0/src/main/promhx/Stream.hx:105: characters 9-23
		return $removed;
	}

	/**
	 * @return Stream
	 */
	public function end () {
		#C:\HaxeToolkit\haxe\lib\promhx/1,1,0/src/main/promhx/Stream.hx:199: characters 9-37
		EventLoop::$queue->add(Boot::getInstanceClosure($this, 'handleEnd'));
		EventLoop::continueOnNextLoop();

		#C:\HaxeToolkit\haxe\lib\promhx/1,1,0/src/main/promhx/Stream.hx:200: characters 9-20
		return $this;
	}

	/**
	 * @param \Closure $f
	 * 
	 * @return Promise
	 */
	public function endThen ($f) {
		#C:\HaxeToolkit\haxe\lib\promhx/1,1,0/src/main/promhx/Stream.hx:204: characters 8-35
		return $this->_end_promise->then($f);
	}

	/**
	 * Pipes an error back into a normal type.
	 * 
	 * @param \Closure $f
	 * 
	 * @return Stream
	 */
	public function errorPipe ($f) {
		#C:\HaxeToolkit\haxe\lib\promhx/1,1,0/src/main/promhx/Stream.hx:171: characters 9-59
		$ret = new Stream(null);
		#C:\HaxeToolkit\haxe\lib\promhx/1,1,0/src/main/promhx/Stream.hx:172: lines 172-176
		$this->catchError(function ($e)  use (&$f, &$ret) {
			#C:\HaxeToolkit\haxe\lib\promhx/1,1,0/src/main/promhx/Stream.hx:173: characters 13-30
			$piped = $f($e);
			#C:\HaxeToolkit\haxe\lib\promhx/1,1,0/src/main/promhx/Stream.hx:174: characters 13-37
			$piped->then(Boot::getInstanceClosure($ret, '_resolve'));
			#C:\HaxeToolkit\haxe\lib\promhx/1,1,0/src/main/promhx/Stream.hx:175: characters 13-63
			$piped->_end_promise->then(Boot::getInstanceClosure($ret->_end_promise, '_resolve'));
		});
		#C:\HaxeToolkit\haxe\lib\promhx/1,1,0/src/main/promhx/Stream.hx:177: characters 9-27
		$this->then(Boot::getInstanceClosure($ret, '_resolve'));
		#C:\HaxeToolkit\haxe\lib\promhx/1,1,0/src/main/promhx/Stream.hx:178: characters 9-49
		$this->_end_promise->then(function ($x)  use (&$ret) {
			#C:\HaxeToolkit\haxe\lib\promhx/1,1,0/src/main/promhx/Stream.hx:178: characters 39-48
			$ret->end();
		});
		#C:\HaxeToolkit\haxe\lib\promhx/1,1,0/src/main/promhx/Stream.hx:179: characters 9-19
		return $ret;
	}

	/**
	 * Creates a new stream linked to the current instance that only updates
	 * if the [f] argument is true.
	 * 
	 * @param \Closure $f
	 * 
	 * @return Stream
	 */
	public function filter ($f) {
		#C:\HaxeToolkit\haxe\lib\promhx/1,1,0/src/main/promhx/Stream.hx:212: characters 9-59
		$ret = new Stream(null);
		#C:\HaxeToolkit\haxe\lib\promhx/1,1,0/src/main/promhx/Stream.hx:213: lines 213-216
		$_this = $this->_update;
		$_this->arr[$_this->length] = new HxAnon([
			"async" => $ret,
			"linkf" => function ($x)  use (&$f, &$ret) {
				#C:\HaxeToolkit\haxe\lib\promhx/1,1,0/src/main/promhx/Stream.hx:215: characters 33-63
				if ($f($x)) {
					#C:\HaxeToolkit\haxe\lib\promhx/1,1,0/src/main/promhx/Stream.hx:215: characters 43-63
					$ret->handleResolve($x);
				}
			},
		]);
		#C:\HaxeToolkit\haxe\lib\promhx/1,1,0/src/main/promhx/Stream.hx:213: lines 213-216
		++$_this->length;

		#C:\HaxeToolkit\haxe\lib\promhx/1,1,0/src/main/promhx/Stream.hx:217: characters 9-71
		AsyncBase::immediateLinkUpdate($this, $ret, function ($x1) {
			#C:\HaxeToolkit\haxe\lib\promhx/1,1,0/src/main/promhx/Stream.hx:217: characters 62-70
			return $x1;
		});
		#C:\HaxeToolkit\haxe\lib\promhx/1,1,0/src/main/promhx/Stream.hx:218: characters 9-19
		return $ret;
	}

	/**
	 * Returns a Promise that will resolve only for the first stream update.
	 * 
	 * @return Promise
	 */
	public function first () {
		#C:\HaxeToolkit\haxe\lib\promhx/1,1,0/src/main/promhx/Stream.hx:142: characters 9-58
		$s = new Promise(null);
		#C:\HaxeToolkit\haxe\lib\promhx/1,1,0/src/main/promhx/Stream.hx:143: characters 9-66
		$this->then(function ($x)  use (&$s) {
			#C:\HaxeToolkit\haxe\lib\promhx/1,1,0/src/main/promhx/Stream.hx:143: characters 26-65
			if (!$s->_resolved) {
				#C:\HaxeToolkit\haxe\lib\promhx/1,1,0/src/main/promhx/Stream.hx:143: characters 47-65
				$s->handleResolve($x);
			}
		});
		#C:\HaxeToolkit\haxe\lib\promhx/1,1,0/src/main/promhx/Stream.hx:144: characters 9-17
		return $s;
	}

	/**
	 * I need this as a private function to call recursively.
	 * 
	 * @return void
	 */
	public function handleEnd () {
		#C:\HaxeToolkit\haxe\lib\promhx/1,1,0/src/main/promhx/Stream.hx:187: lines 187-195
		if ($this->_pending) {
			#C:\HaxeToolkit\haxe\lib\promhx/1,1,0/src/main/promhx/Stream.hx:187: characters 26-54
			EventLoop::$queue->add(Boot::getInstanceClosure($this, 'handleEnd'));
			EventLoop::continueOnNextLoop();
		} else if ($this->_end_promise->_resolved) {
			#C:\HaxeToolkit\haxe\lib\promhx/1,1,0/src/main/promhx/Stream.hx:188: characters 45-51
			return;
		} else {
			#C:\HaxeToolkit\haxe\lib\promhx/1,1,0/src/main/promhx/Stream.hx:190: characters 13-24
			$this->_end = true;
			#C:\HaxeToolkit\haxe\lib\promhx/1,1,0/src/main/promhx/Stream.hx:191: characters 13-54
			$o = ($this->_resolved ? Option::Some($this->_val) : Option::None());
			#C:\HaxeToolkit\haxe\lib\promhx/1,1,0/src/main/promhx/Stream.hx:192: characters 13-42
			$this->_end_promise->handleResolve($o);
			#C:\HaxeToolkit\haxe\lib\promhx/1,1,0/src/main/promhx/Stream.hx:193: characters 13-25
			$this->_update = new \Array_hx();
			#C:\HaxeToolkit\haxe\lib\promhx/1,1,0/src/main/promhx/Stream.hx:194: characters 13-24
			$this->_error = new \Array_hx();
		}
	}

	/**
	 * @param mixed $val
	 * 
	 * @return void
	 */
	public function handleResolve ($val) {
		#C:\HaxeToolkit\haxe\lib\promhx/1,1,0/src/main/promhx/Stream.hx:148: characters 9-44
		if (!$this->_end && !$this->_pause) {
			#C:\HaxeToolkit\haxe\lib\promhx/1,1,0/src/main/promhx/Stream.hx:148: characters 31-44
			$this->_resolve($val);
		}
	}

	/**
	 * Merges another stream into the current one.
	 * 
	 * @param Stream $s
	 * 
	 * @return Stream
	 */
	public function merge ($s) {
		#C:\HaxeToolkit\haxe\lib\promhx/1,1,0/src/main/promhx/Stream.hx:249: characters 9-59
		$ret = new Stream(null);
		#C:\HaxeToolkit\haxe\lib\promhx/1,1,0/src/main/promhx/Stream.hx:250: lines 250-253
		$_this = $this->_update;
		$_this->arr[$_this->length] = new HxAnon([
			"async" => $ret,
			"linkf" => Boot::getInstanceClosure($ret, 'handleResolve'),
		]);
		++$_this->length;

		#C:\HaxeToolkit\haxe\lib\promhx/1,1,0/src/main/promhx/Stream.hx:254: lines 254-257
		$_this1 = $s->_update;
		$_this1->arr[$_this1->length] = new HxAnon([
			"async" => $ret,
			"linkf" => Boot::getInstanceClosure($ret, 'handleResolve'),
		]);
		++$_this1->length;

		#C:\HaxeToolkit\haxe\lib\promhx/1,1,0/src/main/promhx/Stream.hx:258: characters 9-71
		AsyncBase::immediateLinkUpdate($this, $ret, function ($x) {
			#C:\HaxeToolkit\haxe\lib\promhx/1,1,0/src/main/promhx/Stream.hx:258: characters 62-70
			return $x;
		});
		#C:\HaxeToolkit\haxe\lib\promhx/1,1,0/src/main/promhx/Stream.hx:259: characters 9-68
		AsyncBase::immediateLinkUpdate($s, $ret, function ($x1) {
			#C:\HaxeToolkit\haxe\lib\promhx/1,1,0/src/main/promhx/Stream.hx:259: characters 59-67
			return $x1;
		});
		#C:\HaxeToolkit\haxe\lib\promhx/1,1,0/src/main/promhx/Stream.hx:260: characters 9-19
		return $ret;
	}

	/**
	 * Momentarily disable updates for the stream.  Set the pause state with
	 * the argument.  Call it without the argument to toggle the current state.
	 * 
	 * @param bool $set
	 * 
	 * @return void
	 */
	public function pause ($set = null) {
		#C:\HaxeToolkit\haxe\lib\promhx/1,1,0/src/main/promhx/Stream.hx:156: characters 9-39
		if ($set === null) {
			#C:\HaxeToolkit\haxe\lib\promhx/1,1,0/src/main/promhx/Stream.hx:156: characters 26-39
			$set = !$this->_pause;
		}
		#C:\HaxeToolkit\haxe\lib\promhx/1,1,0/src/main/promhx/Stream.hx:157: characters 9-21
		$this->_pause = $set;
	}

	/**
	 * @param \Closure $f
	 * 
	 * @return Stream
	 */
	public function pipe ($f) {
		#C:\HaxeToolkit\haxe\lib\promhx/1,1,0/src/main/promhx/Stream.hx:161: characters 9-59
		$ret = new Stream(null);
		#C:\HaxeToolkit\haxe\lib\promhx/1,1,0/src/main/promhx/Stream.hx:162: characters 9-41
		$ret1 = $ret;
		$f1 = $f;
		$linked = false;
		$linkf = function ($x)  use (&$f1, &$linked, &$ret1) {
			if (!$linked) {
				$linked = true;
				$pipe_ret = $f1($x);
				$_this = $pipe_ret->_update;
				$_this->arr[$_this->length] = new HxAnon([
					"async" => $ret1,
					"linkf" => Boot::getInstanceClosure($ret1, 'handleResolve'),
				]);
				++$_this->length;

				AsyncBase::immediateLinkUpdate($pipe_ret, $ret1, function ($x1) {
					return $x1;
				});
			}
		};
		$_this1 = $this->_update;
		$_this1->arr[$_this1->length] = new HxAnon([
			"async" => $ret1,
			"linkf" => $linkf,
		]);
		++$_this1->length;

		if ($this->_resolved && !$this->_pending) {
			try {
				$linkf($this->_val);
			} catch (\Throwable $__hx__caught_e) {
				CallStack::saveExceptionTrace($__hx__caught_e);
				$__hx__real_e = ($__hx__caught_e instanceof HxException ? $__hx__caught_e->e : $__hx__caught_e);
				$e = $__hx__real_e;
				$ret1->handleError($e);
			}
		}

		#C:\HaxeToolkit\haxe\lib\promhx/1,1,0/src/main/promhx/Stream.hx:163: characters 9-49
		$this->_end_promise->then(function ($x2)  use (&$ret) {
			#C:\HaxeToolkit\haxe\lib\promhx/1,1,0/src/main/promhx/Stream.hx:163: characters 39-48
			$ret->end();
		});
		#C:\HaxeToolkit\haxe\lib\promhx/1,1,0/src/main/promhx/Stream.hx:164: characters 9-19
		return $ret;
	}

	/**
	 * add a wait function directly to the Stream instance.
	 * 
	 * @param \Closure $f
	 * 
	 * @return Stream
	 */
	public function then ($f) {
		#C:\HaxeToolkit\haxe\lib\promhx/1,1,0/src/main/promhx/Stream.hx:82: characters 9-60
		$ret = new Stream(null);
		#C:\HaxeToolkit\haxe\lib\promhx/1,1,0/src/main/promhx/Stream.hx:83: characters 9-37
		$next = $ret;
		$f1 = $f;
		$_this = $this->_update;
		$_this->arr[$_this->length] = new HxAnon([
			"async" => $next,
			"linkf" => function ($x)  use (&$f1, &$next) {
				$tmp = $f1($x);
				$next->handleResolve($tmp);
			},
		]);
		++$_this->length;

		AsyncBase::immediateLinkUpdate($this, $next, $f1);

		#C:\HaxeToolkit\haxe\lib\promhx/1,1,0/src/main/promhx/Stream.hx:84: lines 84-87
		$_this1 = $this->_end_promise->_update;
		$x1 = new HxAnon([
			"async" => $ret->_end_promise,
			"linkf" => function ($x2)  use (&$ret) {
				#C:\HaxeToolkit\haxe\lib\promhx/1,1,0/src/main/promhx/Stream.hx:86: characters 33-42
				$ret->end();
			},
		]);
		#C:\HaxeToolkit\haxe\lib\promhx/1,1,0/src/main/promhx/Stream.hx:84: lines 84-87
		$_this1->arr[$_this1->length] = $x1;
		++$_this1->length;

		#C:\HaxeToolkit\haxe\lib\promhx/1,1,0/src/main/promhx/Stream.hx:88: characters 9-19
		return $ret;
	}
}

Boot::registerClass(Stream::class, 'promhx.Stream');
