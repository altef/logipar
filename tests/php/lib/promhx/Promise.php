<?php
/**
 * Generated by Haxe 4.0.0-rc.2+77068e10c
 */

namespace promhx;

use \php\_Boot\HxAnon;
use \php\Boot;
use \haxe\CallStack;
use \promhx\error\PromiseError;
use \promhx\base\EventLoop;
use \promhx\base\AsyncBase;
use \php\_Boot\HxException;

class Promise extends AsyncBase {
	/**
	 * @var bool
	 */
	public $_rejected;

	/**
	 * Converts any value to a resolved Promise
	 * 
	 * @param mixed $_val
	 * 
	 * @return Promise
	 */
	static public function promise ($_val) {
		#C:\HaxeToolkit\haxe\lib\promhx/1,1,0/src/main/promhx/Promise.hx:150: characters 9-59
		$ret = new Promise();
		#C:\HaxeToolkit\haxe\lib\promhx/1,1,0/src/main/promhx/Promise.hx:151: characters 9-32
		$ret->handleResolve($_val);
		#C:\HaxeToolkit\haxe\lib\promhx/1,1,0/src/main/promhx/Promise.hx:152: characters 9-19
		return $ret;
	}

	/**
	 * Transforms an iterable of promises into a single promise which resolves
	 * to an array of values.
	 * 
	 * @param object $itb
	 * 
	 * @return Promise
	 */
	static public function whenAll ($itb) {
		#C:\HaxeToolkit\haxe\lib\promhx/1,1,0/src/main/promhx/Promise.hx:85: characters 9-77
		$ret = new Promise(null);
		#C:\HaxeToolkit\haxe\lib\promhx/1,1,0/src/main/promhx/Promise.hx:86: characters 9-36
		$all = $itb;
		$next = $ret;
		$cthen = function ($arr, $current, $v)  use (&$next, &$all) {
			if (($arr->length === 0) || AsyncBase::allFulfilled($arr)) {
				$_g = new \Array_hx();
				$a = $all->iterator();
				while ($a->hasNext()) {
					$a1 = $a->next();
					$_g->arr[$_g->length] = ($a1 === $current ? $v : $a1->_val);
					++$_g->length;
				}

				$vals = $_g;
				$next->handleResolve($vals);
			}
			return;
		};
		$a2 = $all->iterator();
		while ($a2->hasNext()) {
			unset($f, $arr1, $current1);
			$a3 = $a2->next();
			$_this = $a3->_update;
			$f = $cthen;
			$_g1 = new \Array_hx();
			$a21 = $all->iterator();
			while ($a21->hasNext()) {
				$a22 = $a21->next();
				if ($a22 !== $a3) {
					$_g1->arr[$_g1->length] = $a22;
					++$_g1->length;
				}
			}

			$arr1 = $_g1;
			$current1 = $a3;
			$x = function ($v1)  use (&$f, &$arr1, &$current1) {
				$f($arr1, $current1, $v1);
				return;
			};
			$_this->arr[$_this->length] = new HxAnon([
				"async" => $next,
				"linkf" => $x,
			]);
			++$_this->length;
		}

		if (AsyncBase::allFulfilled($all)) {
			$_g2 = new \Array_hx();
			$a4 = $all->iterator();
			while ($a4->hasNext()) {
				$a5 = $a4->next();
				$_g2->arr[$_g2->length] = $a5->_val;
				++$_g2->length;
			}

			$next->handleResolve($_g2);
		}

		#C:\HaxeToolkit\haxe\lib\promhx/1,1,0/src/main/promhx/Promise.hx:87: characters 9-19
		return $ret;
	}

	/**
	 * @param Deferred $d
	 * 
	 * @return void
	 */
	public function __construct ($d = null) {
		#C:\HaxeToolkit\haxe\lib\promhx/1,1,0/src/main/promhx/Promise.hx:17: characters 9-37
		parent::__construct($d);
		#C:\HaxeToolkit\haxe\lib\promhx/1,1,0/src/main/promhx/Promise.hx:18: characters 9-26
		$this->_rejected = false;
	}

	/**
	 * Pipes an error back into a normal type.
	 * 
	 * @param \Closure $f
	 * 
	 * @return Promise
	 */
	public function errorPipe ($f) {
		#C:\HaxeToolkit\haxe\lib\promhx/1,1,0/src/main/promhx/Promise.hx:137: characters 9-36
		$ret = new Promise();
		#C:\HaxeToolkit\haxe\lib\promhx/1,1,0/src/main/promhx/Promise.hx:138: lines 138-141
		$this->catchError(function ($e)  use (&$f, &$ret) {
			#C:\HaxeToolkit\haxe\lib\promhx/1,1,0/src/main/promhx/Promise.hx:139: characters 13-30
			$piped = $f($e);
			#C:\HaxeToolkit\haxe\lib\promhx/1,1,0/src/main/promhx/Promise.hx:140: characters 13-37
			$piped->then(Boot::getInstanceClosure($ret, '_resolve'));
		});
		#C:\HaxeToolkit\haxe\lib\promhx/1,1,0/src/main/promhx/Promise.hx:142: characters 9-27
		$this->then(Boot::getInstanceClosure($ret, '_resolve'));
		#C:\HaxeToolkit\haxe\lib\promhx/1,1,0/src/main/promhx/Promise.hx:143: characters 9-19
		return $ret;
	}

	/**
	 * @param mixed $error
	 * 
	 * @return void
	 */
	public function handleError ($error) {
		#C:\HaxeToolkit\haxe\lib\promhx/1,1,0/src/main/promhx/Promise.hx:123: characters 8-24
		$this->_rejected = true;
		#C:\HaxeToolkit\haxe\lib\promhx/1,1,0/src/main/promhx/Promise.hx:124: characters 8-27
		$this->_handleError($error);
	}

	/**
	 * Resolves the given value for processing on any waiting functions.
	 * 
	 * @param mixed $val
	 * 
	 * @return void
	 */
	public function handleResolve ($val) {
		#C:\HaxeToolkit\haxe\lib\promhx/1,1,0/src/main/promhx/Promise.hx:94: lines 94-97
		if ($this->_resolved) {
			#C:\HaxeToolkit\haxe\lib\promhx/1,1,0/src/main/promhx/Promise.hx:95: characters 13-59
			$msg = "Promise has already been resolved";
			#C:\HaxeToolkit\haxe\lib\promhx/1,1,0/src/main/promhx/Promise.hx:96: characters 13-18
			throw new HxException(PromiseError::AlreadyResolved($msg));
		}
		#C:\HaxeToolkit\haxe\lib\promhx/1,1,0/src/main/promhx/Promise.hx:98: characters 9-22
		$this->_resolve($val);
	}

	/**
	 * Utility function to determine if a Promise value has been rejected.
	 * 
	 * @return bool
	 */
	public function isRejected () {
		#C:\HaxeToolkit\haxe\lib\promhx/1,1,0/src/main/promhx/Promise.hx:69: characters 9-25
		return $this->_rejected;
	}

	/**
	 * @param \Closure $f
	 * 
	 * @return Promise
	 */
	public function pipe ($f) {
		#C:\HaxeToolkit\haxe\lib\promhx/1,1,0/src/main/promhx/Promise.hx:128: characters 9-60
		$ret = new Promise(null);
		#C:\HaxeToolkit\haxe\lib\promhx/1,1,0/src/main/promhx/Promise.hx:129: characters 9-41
		$ret1 = $ret;
		$f1 = $f;
		$linked = false;
		$linkf = function ($x)  use (&$f1, &$linked, &$ret1) {
			if (!$linked) {
				$linked = true;
				$pipe_ret = $f1($x);
				$_this = $pipe_ret->_update;
				$_this->arr[$_this->length] = new HxAnon([
					"async" => $ret1,
					"linkf" => Boot::getInstanceClosure($ret1, 'handleResolve'),
				]);
				++$_this->length;

				AsyncBase::immediateLinkUpdate($pipe_ret, $ret1, function ($x1) {
					return $x1;
				});
			}
		};
		$_this1 = $this->_update;
		$_this1->arr[$_this1->length] = new HxAnon([
			"async" => $ret1,
			"linkf" => $linkf,
		]);
		++$_this1->length;

		if ($this->_resolved && !$this->_pending) {
			try {
				$linkf($this->_val);
			} catch (\Throwable $__hx__caught_e) {
				CallStack::saveExceptionTrace($__hx__caught_e);
				$__hx__real_e = ($__hx__caught_e instanceof HxException ? $__hx__caught_e->e : $__hx__caught_e);
				$e = $__hx__real_e;
				$ret1->handleError($e);
			}
		}

		#C:\HaxeToolkit\haxe\lib\promhx/1,1,0/src/main/promhx/Promise.hx:130: characters 9-19
		return $ret;
	}

	/**
	 * Rejects the promise, throwing an error.
	 * 
	 * @param mixed $e
	 * 
	 * @return void
	 */
	public function reject ($e) {
		#C:\HaxeToolkit\haxe\lib\promhx/1,1,0/src/main/promhx/Promise.hx:76: characters 9-25
		$this->_rejected = true;
		#C:\HaxeToolkit\haxe\lib\promhx/1,1,0/src/main/promhx/Promise.hx:77: characters 9-23
		$this->handleError($e);
	}

	/**
	 * add a wait function directly to the Promise instance.
	 * 
	 * @param \Closure $f
	 * 
	 * @return Promise
	 */
	public function then ($f) {
		#C:\HaxeToolkit\haxe\lib\promhx/1,1,0/src/main/promhx/Promise.hx:105: characters 9-61
		$ret = new Promise(null);
		#C:\HaxeToolkit\haxe\lib\promhx/1,1,0/src/main/promhx/Promise.hx:106: characters 9-37
		$next = $ret;
		$f1 = $f;
		$_this = $this->_update;
		$_this->arr[$_this->length] = new HxAnon([
			"async" => $next,
			"linkf" => function ($x)  use (&$f1, &$next) {
				$tmp = $f1($x);
				$next->handleResolve($tmp);
			},
		]);
		++$_this->length;

		AsyncBase::immediateLinkUpdate($this, $next, $f1);

		#C:\HaxeToolkit\haxe\lib\promhx/1,1,0/src/main/promhx/Promise.hx:107: characters 9-19
		return $ret;
	}

	/**
	 * @param AsyncBase $to
	 * 
	 * @return void
	 */
	public function unlink ($to) {
		#C:\HaxeToolkit\haxe\lib\promhx/1,1,0/src/main/promhx/Promise.hx:110: lines 110-120
		$_gthis = $this;
		#C:\HaxeToolkit\haxe\lib\promhx/1,1,0/src/main/promhx/Promise.hx:111: lines 111-119
		EventLoop::$queue->add(function ()  use (&$to, &$_gthis, &$value) {
			#C:\HaxeToolkit\haxe\lib\promhx/1,1,0/src/main/promhx/Promise.hx:112: lines 112-118
			if (!$_gthis->_fulfilled) {
				#C:\HaxeToolkit\haxe\lib\promhx/1,1,0/src/main/promhx/Promise.hx:113: characters 17-66
				$msg = "Downstream Promise is not fullfilled";
				#C:\HaxeToolkit\haxe\lib\promhx/1,1,0/src/main/promhx/Promise.hx:114: characters 17-58
				$_gthis->handleError(PromiseError::DownstreamNotFullfilled($msg));
			} else {
				#C:\HaxeToolkit\haxe\lib\promhx/1,1,0/src/main/promhx/Promise.hx:117: characters 28-76
				$_this = $_gthis->_update;
				$f = function ($x)  use (&$to) {
					#C:\HaxeToolkit\haxe\lib\promhx/1,1,0/src/main/promhx/Promise.hx:117: characters 55-75
					return $x->async !== $to;
				};
				#C:\HaxeToolkit\haxe\lib\promhx/1,1,0/src/main/promhx/Promise.hx:117: characters 28-76
				$result = [];
				$collection = $_this->arr;
				foreach ($collection as $key => $value) {
					if ($f($value)) {
						$result[] = $value;
					}
				}

				$tmp = \Array_hx::wrap($result);
				#C:\HaxeToolkit\haxe\lib\promhx/1,1,0/src/main/promhx/Promise.hx:117: characters 17-76
				$_gthis->_update = $tmp;
			}
		});
		#C:\HaxeToolkit\haxe\lib\promhx/1,1,0/src/main/promhx/Promise.hx:111: lines 111-119
		EventLoop::continueOnNextLoop();

	}
}

Boot::registerClass(Promise::class, 'promhx.Promise');
