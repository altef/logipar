<?php
/**
 * Generated by Haxe 4.0.0-rc.2+77068e10c
 */

use \php\_Boot\HxAnon;
use \php\Boot;
use \php\_Boot\HxClass;
use \haxe\CallStack;
use \php\_Boot\HxClosure;
use \php\_Boot\HxException;
use \php\_Boot\HxEnum;

/**
 * The Haxe Reflection API allows retrieval of type information at runtime.
 * This class complements the more lightweight Reflect class, with a focus on
 * class and enum instances.
 * @see https://haxe.org/manual/types.html
 * @see https://haxe.org/manual/std-reflection.html
 */
class Type {
	/**
	 * Recursively compares two enum instances `a` and `b` by value.
	 * Unlike `a == b`, this function performs a deep equality check on the
	 * arguments of the constructors, if exists.
	 * If `a` or `b` are null, the result is unspecified.
	 * 
	 * @param mixed $a
	 * @param mixed $b
	 * 
	 * @return bool
	 */
	static public function enumEq ($a, $b) {
		#C:\HaxeToolkit\haxe\std/php/_std/Type.hx:262: characters 3-26
		if (Boot::equal($a, $b)) {
			#C:\HaxeToolkit\haxe\std/php/_std/Type.hx:262: characters 15-26
			return true;
		}
		#C:\HaxeToolkit\haxe\std/php/_std/Type.hx:263: characters 3-43
		if (($a === null) || ($b === null)) {
			#C:\HaxeToolkit\haxe\std/php/_std/Type.hx:263: characters 31-43
			return false;
		}
		#C:\HaxeToolkit\haxe\std/php/_std/Type.hx:265: lines 265-295
		try {
			#C:\HaxeToolkit\haxe\std/php/_std/Type.hx:266: characters 4-74
			if (!Boot::equal(get_class($a), get_class($b))) {
				#C:\HaxeToolkit\haxe\std/php/_std/Type.hx:266: characters 62-74
				return false;
			}
			#C:\HaxeToolkit\haxe\std/php/_std/Type.hx:267: characters 4-50
			if (Boot::dynamicField($a, 'index') !== Boot::dynamicField($b, 'index')) {
				#C:\HaxeToolkit\haxe\std/php/_std/Type.hx:267: characters 38-50
				return false;
			}
			#C:\HaxeToolkit\haxe\std/php/_std/Type.hx:269: characters 4-63
			$aParams = Boot::dynamicField($a, 'params');
			#C:\HaxeToolkit\haxe\std/php/_std/Type.hx:270: characters 4-63
			$bParams = Boot::dynamicField($b, 'params');
			#C:\HaxeToolkit\haxe\std/php/_std/Type.hx:271: lines 271-290
			$_g = 0;
			$_g1 = count($aParams);
			while ($_g < $_g1) {
				$i = $_g++;
				#C:\HaxeToolkit\haxe\std/php/_std/Type.hx:273: lines 273-278
				if (($aParams[$i] instanceof HxEnum)) {
					#C:\HaxeToolkit\haxe\std/php/_std/Type.hx:274: lines 274-276
					if (!Type::enumEq($aParams[$i], $bParams[$i])) {
						#C:\HaxeToolkit\haxe\std/php/_std/Type.hx:275: characters 7-19
						return false;
					}
					#C:\HaxeToolkit\haxe\std/php/_std/Type.hx:277: characters 6-14
					continue;
				}
				#C:\HaxeToolkit\haxe\std/php/_std/Type.hx:280: characters 9-39
				$f = $aParams[$i];
				#C:\HaxeToolkit\haxe\std/php/_std/Type.hx:280: lines 280-285
				if (($f instanceof \Closure) || ($f instanceof HxClosure)) {
					#C:\HaxeToolkit\haxe\std/php/_std/Type.hx:281: lines 281-283
					if (!\Reflect::compareMethods($aParams[$i], $bParams[$i])) {
						#C:\HaxeToolkit\haxe\std/php/_std/Type.hx:282: characters 7-19
						return false;
					}
					#C:\HaxeToolkit\haxe\std/php/_std/Type.hx:284: characters 6-14
					continue;
				}
				#C:\HaxeToolkit\haxe\std/php/_std/Type.hx:287: lines 287-289
				if (!Boot::equal($aParams[$i], $bParams[$i])) {
					#C:\HaxeToolkit\haxe\std/php/_std/Type.hx:288: characters 6-18
					return false;
				}
			}

			#C:\HaxeToolkit\haxe\std/php/_std/Type.hx:292: characters 4-15
			return true;
		} catch (\Throwable $__hx__caught_e) {
			CallStack::saveExceptionTrace($__hx__caught_e);
			$__hx__real_e = ($__hx__caught_e instanceof HxException ? $__hx__caught_e->e : $__hx__caught_e);
			$e = $__hx__real_e;
			#C:\HaxeToolkit\haxe\std/php/_std/Type.hx:294: characters 4-16
			return false;
		}
	}

	/**
	 * Returns the class of `o`, if `o` is a class instance.
	 * If `o` is null or of a different type, null is returned.
	 * In general, type parameter information cannot be obtained at runtime.
	 * 
	 * @param mixed $o
	 * 
	 * @return Class
	 */
	static public function getClass ($o) {
		#C:\HaxeToolkit\haxe\std/php/_std/Type.hx:44: lines 44-51
		if (is_object($o) && !($o instanceof HxClass) && !($o instanceof HxEnum)) {
			#C:\HaxeToolkit\haxe\std/php/_std/Type.hx:45: characters 4-54
			$cls = Boot::getClass(get_class($o));
			#C:\HaxeToolkit\haxe\std/php/_std/Type.hx:46: characters 11-54
			if ($cls === Boot::getClass(HxAnon::class)) {
				#C:\HaxeToolkit\haxe\std/php/_std/Type.hx:46: characters 38-42
				return null;
			} else {
				#C:\HaxeToolkit\haxe\std/php/_std/Type.hx:46: characters 45-53
				return $cls;
			}
		} else if (is_string($o)) {
			#C:\HaxeToolkit\haxe\std/php/_std/Type.hx:48: characters 4-22
			return Boot::getClass('String');
		} else {
			#C:\HaxeToolkit\haxe\std/php/_std/Type.hx:50: characters 4-15
			return null;
		}
	}

	/**
	 * Returns the name of class `c`, including its path.
	 * If `c` is inside a package, the package structure is returned dot-
	 * separated, with another dot separating the class name:
	 * `pack1.pack2.(...).packN.ClassName`
	 * If `c` is a sub-type of a Haxe module, that module is not part of the
	 * package structure.
	 * If `c` has no package, the class name is returned.
	 * If `c` is null, the result is unspecified.
	 * The class name does not include any type parameters.
	 * 
	 * @param Class $c
	 * 
	 * @return string
	 */
	static public function getClassName ($c) {
		#C:\HaxeToolkit\haxe\std/php/_std/Type.hx:67: characters 3-28
		if ($c === null) {
			#C:\HaxeToolkit\haxe\std/php/_std/Type.hx:67: characters 17-28
			return null;
		}
		#C:\HaxeToolkit\haxe\std/php/_std/Type.hx:68: characters 3-34
		return Boot::getHaxeName($c);
	}
}

Boot::registerClass(Type::class, 'Type');
