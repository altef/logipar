# Generated by Haxe 4.0.0-rc.2+77068e10c
# coding: utf-8

from datetime import datetime as python_lib_datetime_Datetime
import math as python_lib_Math
import math as Math
import inspect as python_lib_Inspect
import sys as buddy_PythonSys
from threading import Timer as buddy_tools_Timer
import builtins as python_lib_Builtins
import functools as python_lib_Functools
import re as python_lib_Re
import sys as python_lib_Sys
import time as python_lib_Time
import timeit as python_lib_Timeit
import traceback as python_lib_Traceback
from io import StringIO as python_lib_io_StringIO


class _hx_AnonObject:
    def __init__(self, fields):
        self.__dict__ = fields
    def __repr__(self):
        return repr(self.__dict__)


class Enum:
    _hx_class_name = "Enum"
    __slots__ = ("tag", "index", "params")
    _hx_fields = ["tag", "index", "params"]
    _hx_methods = ["__str__"]

    def __init__(self,tag,index,params):
        self.tag = tag
        self.index = index
        self.params = params

    def __str__(self):
        if (self.params is None):
            return self.tag
        else:
            _this = self.params
            return (((HxOverrides.stringOrNull(self.tag) + "(") + HxOverrides.stringOrNull(",".join([python_Boot.toString1(x1,'') for x1 in _this]))) + ")")

Enum._hx_class = Enum


class AsyncTools:
    _hx_class_name = "AsyncTools"
    __slots__ = ()
    _hx_statics = ["aMapLimit", "aMapSeries", "aEachLimit", "aEachSeries", "aForEachOfMapLimit"]

    @staticmethod
    def aMapLimit(iterable,limit,cb,done):
        def _hx_local_0(item,_,done1):
            cb(item,done1)
        AsyncTools.aForEachOfMapLimit(iterable,limit,_hx_local_0,done)

    @staticmethod
    def aMapSeries(iterable,cb,done):
        AsyncTools.aMapLimit(iterable,1,cb,done)

    @staticmethod
    def aEachLimit(iterable,limit,cb,done):
        def _hx_local_1(item,done1):
            def _hx_local_0(err = None):
                done1(err,True)
            cb(item,_hx_local_0)
        def _hx_local_2(err1,items):
            done(err1)
        AsyncTools.aMapLimit(iterable,limit,_hx_local_1,_hx_local_2)

    @staticmethod
    def aEachSeries(iterable,cb,done):
        AsyncTools.aEachLimit(iterable,1,cb,done)

    @staticmethod
    def aForEachOfMapLimit(iterable,limit,cb,done):
        complete = haxe_ds_IntMap()
        it = HxOverrides.iterator(iterable)
        completed = False
        running = 0
        pos = 0
        def _hx_local_0():
            currentPos = pos
            _g = []
            _g1 = 0
            _g2 = currentPos
            while (_g1 < _g2):
                key = _g1
                _g1 = (_g1 + 1)
                x = complete.h.get(key,None)
                _g.append(x)
            output = _g
            return output
        completedItems = _hx_local_0
        next = None
        def _hx_local_5():
            nonlocal running
            nonlocal pos
            nonlocal completed
            if (not completed):
                if (not it.hasNext()):
                    if (running <= 0):
                        if (not completed):
                            completed = True
                            next1 = completedItems()
                            done(None,next1)
                else:
                    nextItem = it.next()
                    pos = (pos + 1)
                    currentPos1 = (pos - 1)
                    running = (running + 1)
                    def _hx_local_4(err,mapped):
                        nonlocal running
                        nonlocal completed
                        if (not completed):
                            if (err is not None):
                                if (not completed):
                                    completed = True
                                    next2 = completedItems()
                                    done(err,next2)
                            else:
                                running = (running - 1)
                                complete.set(currentPos1,mapped)
                                next()
                    cb(nextItem,currentPos1,_hx_local_4)
                    if (not completed):
                        if ((limit == 0) or ((running < limit))):
                            next()
        next = _hx_local_5
        next()
AsyncTools._hx_class = AsyncTools


class Class: pass


class Date:
    _hx_class_name = "Date"
    __slots__ = ("date",)
    _hx_fields = ["date"]
    _hx_statics = ["fromString"]

    def __init__(self,year,month,day,hour,_hx_min,sec):
        if (year < python_lib_datetime_Datetime.min.year):
            year = python_lib_datetime_Datetime.min.year
        if (day == 0):
            day = 1
        self.date = python_lib_datetime_Datetime(year,(month + 1),day,hour,_hx_min,sec,0)

    @staticmethod
    def fromString(s):
        _g = len(s)
        if (_g == 8):
            k = s.split(":")
            d = Date(0,0,0,Std.parseInt((k[0] if 0 < len(k) else None)),Std.parseInt((k[1] if 1 < len(k) else None)),Std.parseInt((k[2] if 2 < len(k) else None)))
            return d
        elif (_g == 10):
            k1 = s.split("-")
            return Date(Std.parseInt((k1[0] if 0 < len(k1) else None)),(Std.parseInt((k1[1] if 1 < len(k1) else None)) - 1),Std.parseInt((k1[2] if 2 < len(k1) else None)),0,0,0)
        elif (_g == 19):
            k2 = s.split(" ")
            _this = (k2[0] if 0 < len(k2) else None)
            y = _this.split("-")
            _this1 = (k2[1] if 1 < len(k2) else None)
            t = _this1.split(":")
            return Date(Std.parseInt((y[0] if 0 < len(y) else None)),(Std.parseInt((y[1] if 1 < len(y) else None)) - 1),Std.parseInt((y[2] if 2 < len(y) else None)),Std.parseInt((t[0] if 0 < len(t) else None)),Std.parseInt((t[1] if 1 < len(t) else None)),Std.parseInt((t[2] if 2 < len(t) else None)))
        else:
            raise _HxException(("Invalid date format : " + ("null" if s is None else s)))

Date._hx_class = Date


class EReg:
    _hx_class_name = "EReg"
    __slots__ = ("pattern", "matchObj", "_hx_global")
    _hx_fields = ["pattern", "matchObj", "global"]

    def __init__(self,r,opt):
        self.matchObj = None
        self._hx_global = False
        options = 0
        _g = 0
        _g1 = len(opt)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            c = (-1 if ((i >= len(opt))) else ord(opt[i]))
            if (c == 109):
                options = (options | python_lib_Re.M)
            if (c == 105):
                options = (options | python_lib_Re.I)
            if (c == 115):
                options = (options | python_lib_Re.S)
            if (c == 117):
                options = (options | python_lib_Re.U)
            if (c == 103):
                self._hx_global = True
        self.pattern = python_lib_Re.compile(r,options)

EReg._hx_class = EReg


class Lambda:
    _hx_class_name = "Lambda"
    __slots__ = ()
    _hx_statics = ["array", "exists", "iter", "filter", "empty"]

    @staticmethod
    def array(it):
        a = list()
        i = HxOverrides.iterator(it)
        while i.hasNext():
            i1 = i.next()
            a.append(i1)
        return a

    @staticmethod
    def exists(it,f):
        x = HxOverrides.iterator(it)
        while x.hasNext():
            x1 = x.next()
            if f(x1):
                return True
        return False

    @staticmethod
    def iter(it,f):
        x = HxOverrides.iterator(it)
        while x.hasNext():
            x1 = x.next()
            f(x1)

    @staticmethod
    def filter(it,f):
        _g = []
        x = HxOverrides.iterator(it)
        while x.hasNext():
            x1 = x.next()
            if f(x1):
                _g.append(x1)
        return _g

    @staticmethod
    def empty(it):
        return (not HxOverrides.iterator(it).hasNext())
Lambda._hx_class = Lambda


class Reflect:
    _hx_class_name = "Reflect"
    __slots__ = ()
    _hx_statics = ["field"]

    @staticmethod
    def field(o,field):
        return python_Boot.field(o,field)
Reflect._hx_class = Reflect


class Std:
    _hx_class_name = "Std"
    __slots__ = ()
    _hx_statics = ["is", "string", "parseInt", "shortenPossibleNumber", "parseFloat"]

    @staticmethod
    def _hx_is(v,t):
        if ((v is None) and ((t is None))):
            return False
        if (t is None):
            return False
        if (t == Dynamic):
            return (v is not None)
        isBool = isinstance(v,bool)
        if ((t == Bool) and isBool):
            return True
        if ((((not isBool) and (not (t == Bool))) and (t == Int)) and isinstance(v,int)):
            return True
        vIsFloat = isinstance(v,float)
        tmp = None
        tmp1 = None
        if (((not isBool) and vIsFloat) and (t == Int)):
            f = v
            tmp1 = (((f != Math.POSITIVE_INFINITY) and ((f != Math.NEGATIVE_INFINITY))) and (not python_lib_Math.isnan(f)))
        else:
            tmp1 = False
        if tmp1:
            tmp2 = None
            try:
                tmp2 = int(v)
            except Exception as _hx_e:
                _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                e = _hx_e1
                tmp2 = None
            tmp = (v == tmp2)
        else:
            tmp = False
        if ((tmp and ((v <= 2147483647))) and ((v >= -2147483648))):
            return True
        if (((not isBool) and (t == Float)) and isinstance(v,(float, int))):
            return True
        if (t == str):
            return isinstance(v,str)
        isEnumType = (t == Enum)
        if ((isEnumType and python_lib_Inspect.isclass(v)) and hasattr(v,"_hx_constructs")):
            return True
        if isEnumType:
            return False
        isClassType = (t == Class)
        if ((((isClassType and (not isinstance(v,Enum))) and python_lib_Inspect.isclass(v)) and hasattr(v,"_hx_class_name")) and (not hasattr(v,"_hx_constructs"))):
            return True
        if isClassType:
            return False
        tmp3 = None
        try:
            tmp3 = isinstance(v,t)
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e1 = _hx_e1
            tmp3 = False
        if tmp3:
            return True
        if python_lib_Inspect.isclass(t):
            loop = None
            def _hx_local_1(intf):
                f1 = (intf._hx_interfaces if (hasattr(intf,"_hx_interfaces")) else [])
                if (f1 is not None):
                    _g = 0
                    while (_g < len(f1)):
                        i = (f1[_g] if _g >= 0 and _g < len(f1) else None)
                        _g = (_g + 1)
                        if HxOverrides.eq(i,t):
                            return True
                        else:
                            l = loop(i)
                            if l:
                                return True
                    return False
                else:
                    return False
            loop = _hx_local_1
            currentClass = v.__class__
            while (currentClass is not None):
                if loop(currentClass):
                    return True
                currentClass = python_Boot.getSuperClass(currentClass)
            return False
        else:
            return False

    @staticmethod
    def string(s):
        return python_Boot.toString1(s,"")

    @staticmethod
    def parseInt(x):
        if (x is None):
            return None
        try:
            return int(x)
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e = _hx_e1
            try:
                prefix = HxString.substr(x,0,2).lower()
                if (prefix == "0x"):
                    return int(x,16)
                raise _HxException("fail")
            except Exception as _hx_e:
                _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                e1 = _hx_e1
                x1 = Std.parseFloat(x)
                r = None
                try:
                    r = int(x1)
                except Exception as _hx_e:
                    _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                    e2 = _hx_e1
                    r = None
                if (r is None):
                    r1 = Std.shortenPossibleNumber(x)
                    if (r1 != x):
                        return Std.parseInt(r1)
                    else:
                        return None
                return r

    @staticmethod
    def shortenPossibleNumber(x):
        r = ""
        _g = 0
        _g1 = len(x)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            c = ("" if (((i < 0) or ((i >= len(x))))) else x[i])
            _g2 = HxString.charCodeAt(c,0)
            if (_g2 is None):
                break
            else:
                _g3 = _g2
                if (((((((((((_g3 == 57) or ((_g3 == 56))) or ((_g3 == 55))) or ((_g3 == 54))) or ((_g3 == 53))) or ((_g3 == 52))) or ((_g3 == 51))) or ((_g3 == 50))) or ((_g3 == 49))) or ((_g3 == 48))) or ((_g3 == 46))):
                    r = (("null" if r is None else r) + ("null" if c is None else c))
                else:
                    break
        return r

    @staticmethod
    def parseFloat(x):
        try:
            return float(x)
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e = _hx_e1
            if (x is not None):
                r1 = Std.shortenPossibleNumber(x)
                if (r1 != x):
                    return Std.parseFloat(r1)
            return Math.NaN
Std._hx_class = Std


class Float: pass


class Int: pass


class Bool: pass


class Dynamic: pass


class StringBuf:
    _hx_class_name = "StringBuf"
    __slots__ = ("b",)
    _hx_fields = ["b"]
    _hx_methods = ["get_length"]

    def __init__(self):
        self.b = python_lib_io_StringIO()

    def get_length(self):
        pos = self.b.tell()
        self.b.seek(0,2)
        _hx_len = self.b.tell()
        self.b.seek(pos,0)
        return _hx_len

StringBuf._hx_class = StringBuf


class StringTools:
    _hx_class_name = "StringTools"
    __slots__ = ()
    _hx_statics = ["isSpace", "ltrim", "rtrim", "trim", "lpad"]

    @staticmethod
    def isSpace(s,pos):
        if (((len(s) == 0) or ((pos < 0))) or ((pos >= len(s)))):
            return False
        c = HxString.charCodeAt(s,pos)
        if (not (((c > 8) and ((c < 14))))):
            return (c == 32)
        else:
            return True

    @staticmethod
    def ltrim(s):
        l = len(s)
        r = 0
        while ((r < l) and StringTools.isSpace(s,r)):
            r = (r + 1)
        if (r > 0):
            return HxString.substr(s,r,(l - r))
        else:
            return s

    @staticmethod
    def rtrim(s):
        l = len(s)
        r = 0
        while ((r < l) and StringTools.isSpace(s,((l - r) - 1))):
            r = (r + 1)
        if (r > 0):
            return HxString.substr(s,0,(l - r))
        else:
            return s

    @staticmethod
    def trim(s):
        return StringTools.ltrim(StringTools.rtrim(s))

    @staticmethod
    def lpad(s,c,l):
        if (len(c) <= 0):
            return s
        buf = StringBuf()
        l = (l - len(s))
        while (buf.get_length() < l):
            s1 = Std.string(c)
            buf.b.write(s1)
        s2 = Std.string(s)
        buf.b.write(s2)
        return buf.b.getvalue()
StringTools._hx_class = StringTools


class haxe_IMap:
    _hx_class_name = "haxe.IMap"
    __slots__ = ()
    _hx_methods = ["toString"]
haxe_IMap._hx_class = haxe_IMap


class haxe_ds_StringMap:
    _hx_class_name = "haxe.ds.StringMap"
    __slots__ = ("h",)
    _hx_fields = ["h"]
    _hx_methods = ["keys", "iterator", "toString"]
    _hx_interfaces = [haxe_IMap]

    def __init__(self):
        self.h = dict()

    def keys(self):
        return python_HaxeIterator(iter(self.h.keys()))

    def iterator(self):
        return python_HaxeIterator(iter(self.h.values()))

    def toString(self):
        s_b = python_lib_io_StringIO()
        s_b.write("{")
        it = self.keys()
        i = it
        while i.hasNext():
            i1 = i.next()
            s_b.write(Std.string(i1))
            s_b.write(" => ")
            s_b.write(Std.string(Std.string(self.h.get(i1,None))))
            if it.hasNext():
                s_b.write(", ")
        s_b.write("}")
        return s_b.getvalue()

haxe_ds_StringMap._hx_class = haxe_ds_StringMap


class python_HaxeIterator:
    _hx_class_name = "python.HaxeIterator"
    __slots__ = ("it", "x", "has", "checked")
    _hx_fields = ["it", "x", "has", "checked"]
    _hx_methods = ["next", "hasNext"]

    def __init__(self,it):
        self.checked = False
        self.has = False
        self.x = None
        self.it = it

    def next(self):
        if (not self.checked):
            self.hasNext()
        self.checked = False
        return self.x

    def hasNext(self):
        if (not self.checked):
            try:
                self.x = self.it.__next__()
                self.has = True
            except Exception as _hx_e:
                _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                if isinstance(_hx_e1, StopIteration):
                    s = _hx_e1
                    self.has = False
                    self.x = None
                else:
                    raise _hx_e
            self.checked = True
        return self.has

python_HaxeIterator._hx_class = python_HaxeIterator


class Sys:
    _hx_class_name = "Sys"
    __slots__ = ()
    _hx_statics = ["exit", "sleep"]

    @staticmethod
    def exit(code):
        python_lib_Sys.exit(code)

    @staticmethod
    def sleep(seconds):
        python_lib_Time.sleep(seconds)
Sys._hx_class = Sys


class buddy_BuddySuite:
    _hx_class_name = "buddy.BuddySuite"
    __slots__ = ("suite", "currentSuite", "describeQueue", "timeoutMs", "fail", "pending")
    _hx_fields = ["suite", "currentSuite", "describeQueue", "timeoutMs", "fail", "pending"]
    _hx_methods = ["describe", "it"]
    _hx_statics = ["useDefaultTrace"]

    def __init__(self):
        self.pending = None
        self.fail = None
        self.timeoutMs = 5000
        def _hx_local_0():
            self.currentSuite = buddy_TestSuite("")
            return self.currentSuite
        self.suite = _hx_local_0()
        self.describeQueue = list()

    def describe(self,description,spec,_hasInclude = False):
        if (_hasInclude is None):
            _hasInclude = False
        suite = buddy_TestSuite(description)
        self.currentSuite.specs.add(buddy_TestSpec.Describe(suite,_hasInclude))
        _this = self.describeQueue
        _this.append(_hx_AnonObject({'suite': suite, 'spec': spec}))

    def it(self,desc,spec = None,_hasInclude = False,pos = None,time = 0):
        if (_hasInclude is None):
            _hasInclude = False
        if (time is None):
            time = 0
        if (self.currentSuite == self.suite):
            raise _HxException("Cannot use 'it' outside of a describe block.")
        self.currentSuite.specs.add(buddy_TestSpec.It(desc,spec,_hasInclude,pos,time))

buddy_BuddySuite._hx_class = buddy_BuddySuite


class buddy_SingleSuite(buddy_BuddySuite):
    _hx_class_name = "buddy.SingleSuite"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = []
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = buddy_BuddySuite


    def __init__(self):
        super().__init__()
buddy_SingleSuite._hx_class = buddy_SingleSuite


class Test(buddy_SingleSuite):
    _hx_class_name = "Test"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = []
    _hx_statics = ["main"]
    _hx_interfaces = []
    _hx_super = buddy_SingleSuite


    def __init__(self):
        _gthis = self
        super().__init__()
        def _hx_local_3():
            l = logipar_Logipar()
            l.overwrite("AND","et")
            l.overwrite("OR","ou")
            l.overwrite("XOR","xou")
            l.overwrite("NOT","non")
            l.overwrite("OPEN","[")
            l.overwrite("CLOSE","]")
            tests = [["[one ou two] et three ou non four", "((({one} OR {two}) AND {three}) OR NOT({four}))"]]
            _g = 0
            while (_g < len(tests)):
                t = [(tests[_g] if _g >= 0 and _g < len(tests) else None)]
                _g = (_g + 1)
                tmp = ("Testing: " + HxOverrides.stringOrNull(python_internal_ArrayImpl._get((t[0] if 0 < len(t) else None), 0)))
                def _hx_local_2(t1):
                    def _hx_local_1():
                        l.parse(python_internal_ArrayImpl._get((t1[0] if 0 < len(t1) else None), 0))
                        buddy_ShouldString.should(l.stringify()).be(python_internal_ArrayImpl._get((t1[0] if 0 < len(t1) else None), 1),_hx_AnonObject({'fileName': "src/Test.hx", 'lineNumber': 28, 'className': "Test", 'methodName': "new"}))
                    return _hx_local_1
                tmp1 = buddy_TestFunc.Sync(_hx_local_2(t))
                _gthis.it(tmp,tmp1,None,_hx_AnonObject({'fileName': "src/Test.hx", 'lineNumber': 26, 'className': "Test", 'methodName': "new"}))
        self.describe("Overwriting syntax",buddy_TestFunc.Sync(_hx_local_3))
        def _hx_local_7():
            l1 = logipar_Logipar()
            _this = l1.quotations
            _this.append("`")
            tests1 = [["one=`hello there`", "{one=`hello there`}"], ["\"one and two\" OR 'three'", "({\"one and two\"} OR {'three'})"]]
            _g1 = 0
            while (_g1 < len(tests1)):
                t2 = [(tests1[_g1] if _g1 >= 0 and _g1 < len(tests1) else None)]
                _g1 = (_g1 + 1)
                tmp2 = ("Testing: " + HxOverrides.stringOrNull(python_internal_ArrayImpl._get((t2[0] if 0 < len(t2) else None), 0)))
                def _hx_local_6(t3):
                    def _hx_local_5():
                        l1.parse(python_internal_ArrayImpl._get((t3[0] if 0 < len(t3) else None), 0))
                        buddy_ShouldString.should(l1.stringify()).be(python_internal_ArrayImpl._get((t3[0] if 0 < len(t3) else None), 1),_hx_AnonObject({'fileName': "src/Test.hx", 'lineNumber': 43, 'className': "Test", 'methodName': "new"}))
                    return _hx_local_5
                tmp3 = buddy_TestFunc.Sync(_hx_local_6(t2))
                _gthis.it(tmp2,tmp3,None,_hx_AnonObject({'fileName': "src/Test.hx", 'lineNumber': 41, 'className': "Test", 'methodName': "new"}))
        self.describe("Testing quotation marks",buddy_TestFunc.Sync(_hx_local_7))
        def _hx_local_11():
            l2 = logipar_Logipar()
            l2.caseSensitive = False
            tests2 = [["a and b or c", "(({a} AND {b}) OR {c})"]]
            _g2 = 0
            while (_g2 < len(tests2)):
                t4 = [(tests2[_g2] if _g2 >= 0 and _g2 < len(tests2) else None)]
                _g2 = (_g2 + 1)
                tmp4 = ("Testing: " + HxOverrides.stringOrNull(python_internal_ArrayImpl._get((t4[0] if 0 < len(t4) else None), 0)))
                def _hx_local_10(t5):
                    def _hx_local_9():
                        l2.parse(python_internal_ArrayImpl._get((t5[0] if 0 < len(t5) else None), 0))
                        buddy_ShouldString.should(l2.stringify()).be(python_internal_ArrayImpl._get((t5[0] if 0 < len(t5) else None), 1),_hx_AnonObject({'fileName': "src/Test.hx", 'lineNumber': 58, 'className': "Test", 'methodName': "new"}))
                    return _hx_local_9
                tmp5 = buddy_TestFunc.Sync(_hx_local_10(t4))
                _gthis.it(tmp4,tmp5,None,_hx_AnonObject({'fileName': "src/Test.hx", 'lineNumber': 56, 'className': "Test", 'methodName': "new"}))
        self.describe("Testing case-insensitivity",buddy_TestFunc.Sync(_hx_local_11))
        def _hx_local_15():
            l3 = logipar_Logipar()
            tests3 = [["NOT a OR b", "(NOT({a}) OR {b})"], ["NOT a AND b", "NOT(({a} AND {b}))"], ["a AND b XOR c AND d", "(({a} AND {b}) XOR ({c} AND {d}))"]]
            _g3 = 0
            while (_g3 < len(tests3)):
                t6 = [(tests3[_g3] if _g3 >= 0 and _g3 < len(tests3) else None)]
                _g3 = (_g3 + 1)
                tmp6 = ("Testing: " + HxOverrides.stringOrNull(python_internal_ArrayImpl._get((t6[0] if 0 < len(t6) else None), 0)))
                def _hx_local_14(t7):
                    def _hx_local_13():
                        l3.parse(python_internal_ArrayImpl._get((t7[0] if 0 < len(t7) else None), 0))
                        buddy_ShouldString.should(l3.stringify()).be(python_internal_ArrayImpl._get((t7[0] if 0 < len(t7) else None), 1),_hx_AnonObject({'fileName': "src/Test.hx", 'lineNumber': 75, 'className': "Test", 'methodName': "new"}))
                    return _hx_local_13
                tmp7 = buddy_TestFunc.Sync(_hx_local_14(t6))
                _gthis.it(tmp6,tmp7,None,_hx_AnonObject({'fileName': "src/Test.hx", 'lineNumber': 73, 'className': "Test", 'methodName': "new"}))
        self.describe("Other random logic tests",buddy_TestFunc.Sync(_hx_local_15))
        def _hx_local_21():
            l4 = logipar_Logipar()
            tests4 = [["NOT a OR b", "(NOT(a) OR b)"], ["NOT a AND b", "NOT((a AND b))"], ["a XOR b", "((a AND NOT b) OR (NOT a AND b))"]]
            _g4 = 0
            while (_g4 < len(tests4)):
                t8 = [(tests4[_g4] if _g4 >= 0 and _g4 < len(tests4) else None)]
                _g4 = (_g4 + 1)
                tmp8 = ("Testing: " + HxOverrides.stringOrNull(python_internal_ArrayImpl._get((t8[0] if 0 < len(t8) else None), 0)))
                def _hx_local_20(t9):
                    def _hx_local_17():
                        l4.parse(python_internal_ArrayImpl._get((t9[0] if 0 < len(t9) else None), 0))
                        def _hx_local_19():
                            def _hx_local_18(n):
                                if (n.token.type == "XOR"):
                                    return (((((((("((" + HxOverrides.stringOrNull(n.f(n.left))) + " AND NOT ") + HxOverrides.stringOrNull(n.f(n.right))) + ") OR (NOT ") + HxOverrides.stringOrNull(n.f(n.left))) + " AND ") + HxOverrides.stringOrNull(n.f(n.right))) + "))")
                                if (n.token.type == "LITERAL"):
                                    return Std.string(n.token.literal)
                                return None
                            return _hx_local_18
                        tmp10 = _hx_local_19()
                        buddy_ShouldString.should(l4.stringify(tmp10)).be(python_internal_ArrayImpl._get((t9[0] if 0 < len(t9) else None), 1),_hx_AnonObject({'fileName': "src/Test.hx", 'lineNumber': 91, 'className': "Test", 'methodName': "new"}))
                    return _hx_local_17
                tmp9 = buddy_TestFunc.Sync(_hx_local_20(t8))
                _gthis.it(tmp8,tmp9,None,_hx_AnonObject({'fileName': "src/Test.hx", 'lineNumber': 89, 'className': "Test", 'methodName': "new"}))
        self.describe("Testing a custom string",buddy_TestFunc.Sync(_hx_local_21))

    @staticmethod
    def main():
        testsDone = False
        runner = None
        oldTrace = haxe_Log.trace
        def _hx_local_1():
            haxe_Log.trace = oldTrace
            pos = _hx_AnonObject({'fileName': "Buddy", 'lineNumber': 0, 'className': "", 'methodName': ""})
            haxe_Log.trace(runner.unrecoverableError,pos)
            stack = runner.unrecoverableErrorStack
            if ((stack is None) or ((len(stack) == 0))):
                return
            _g = 0
            while (_g < len(stack)):
                s = (stack[_g] if _g >= 0 and _g < len(stack) else None)
                _g = (_g + 1)
                if (s.index == 2):
                    line = s.params[2]
                    file = s.params[1]
                    if (line > 0):
                        haxe_Log.trace(((("null" if file is None else file) + ":") + Std.string(line)),pos)
        outputError = _hx_local_1
        def _hx_local_3(done):
            nonlocal runner
            runner = buddy_SuitesRunner([Test()],buddy_reporting_ConsoleReporter())
            r = runner.run()
            def _hx_local_2(_):
                if (runner.unrecoverableError is not None):
                    outputError()
                done()
            r.then(_hx_local_2)
        startRun = _hx_local_3
        def _hx_local_4():
            nonlocal testsDone
            testsDone = True
        startRun(_hx_local_4)
        while (not testsDone):
            Sys.sleep(0.1)
        Sys.exit(runner.statusCode())
Test._hx_class = Test


class Type:
    _hx_class_name = "Type"
    __slots__ = ()
    _hx_statics = ["getClass", "getClassName", "enumEq"]

    @staticmethod
    def getClass(o):
        if (o is None):
            return None
        o1 = o
        if ((o1 is not None) and ((HxOverrides.eq(o1,str) or python_lib_Inspect.isclass(o1)))):
            return None
        if isinstance(o,_hx_AnonObject):
            return None
        if hasattr(o,"_hx_class"):
            return o._hx_class
        if hasattr(o,"__class__"):
            return o.__class__
        else:
            return None

    @staticmethod
    def getClassName(c):
        if hasattr(c,"_hx_class_name"):
            return c._hx_class_name
        else:
            if (c == list):
                return "Array"
            if (c == Math):
                return "Math"
            if (c == str):
                return "String"
            try:
                return c.__name__
            except Exception as _hx_e:
                _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                e = _hx_e1
                return None

    @staticmethod
    def enumEq(a,b):
        if HxOverrides.eq(a,b):
            return True
        try:
            if ((b is None) and (not HxOverrides.eq(a,b))):
                return False
            if (a.tag != b.tag):
                return False
            p1 = a.params
            p2 = b.params
            if (len(p1) != len(p2)):
                return False
            _g = 0
            _g1 = len(p1)
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                if (not Type.enumEq((p1[i] if i >= 0 and i < len(p1) else None),(p2[i] if i >= 0 and i < len(p2) else None))):
                    return False
            if (a._hx_class != b._hx_class):
                return False
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e = _hx_e1
            return False
        return True
Type._hx_class = Type

class buddy_SpecStatus(Enum):
    __slots__ = ()
    _hx_class_name = "buddy.SpecStatus"
    _hx_constructs = ["Unknown", "Passed", "Pending", "Failed"]
buddy_SpecStatus.Unknown = buddy_SpecStatus("Unknown", 0, list())
buddy_SpecStatus.Passed = buddy_SpecStatus("Passed", 1, list())
buddy_SpecStatus.Pending = buddy_SpecStatus("Pending", 2, list())
buddy_SpecStatus.Failed = buddy_SpecStatus("Failed", 3, list())
buddy_SpecStatus._hx_class = buddy_SpecStatus

class buddy_Step(Enum):
    __slots__ = ()
    _hx_class_name = "buddy.Step"
    _hx_constructs = ["TSuite", "TSpec"]

    @staticmethod
    def TSuite(s):
        return buddy_Step("TSuite", 0, [s])

    @staticmethod
    def TSpec(s):
        return buddy_Step("TSpec", 1, [s])
buddy_Step._hx_class = buddy_Step


class buddy_Suite:
    _hx_class_name = "buddy.Suite"
    __slots__ = ("description", "steps", "error", "stack")
    _hx_fields = ["description", "steps", "error", "stack"]
    _hx_methods = ["get_specs", "get_suites", "passed"]

    def __init__(self,description):
        self.error = None
        self.stack = list()
        self.steps = list()
        if (description is None):
            raise _HxException("Suite requires a description.")
        self.description = description

    def get_specs(self):
        output = []
        _g = 0
        _g1 = self.steps
        while (_g < len(_g1)):
            step = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if (step.index == 1):
                s = step.params[0]
                output.append(s)
        return output

    def get_suites(self):
        output = []
        _g = 0
        _g1 = self.steps
        while (_g < len(_g1)):
            step = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if (step.index == 0):
                s = step.params[0]
                output.append(s)
        return output

    def passed(self):
        def _hx_local_0(spec):
            return (spec.status == buddy_SpecStatus.Failed)
        if Lambda.exists(self.get_specs(),_hx_local_0):
            return False
        def _hx_local_2():
            def _hx_local_1(suite):
                return (not suite.passed())
            return (not Lambda.exists(self.get_suites(),_hx_local_1))
        return _hx_local_2()

buddy_Suite._hx_class = buddy_Suite


class buddy_Spec:
    _hx_class_name = "buddy.Spec"
    __slots__ = ("description", "status", "failures", "traces", "fileName", "time")
    _hx_fields = ["description", "status", "failures", "traces", "fileName", "time"]

    def __init__(self,description,fileName):
        self.time = 0
        self.fileName = ""
        self.traces = list()
        self.failures = list()
        self.status = buddy_SpecStatus.Unknown
        if (description is None):
            raise _HxException("Spec must have a description.")
        self.description = description
        self.fileName = fileName

buddy_Spec._hx_class = buddy_Spec


class buddy_Failure:
    _hx_class_name = "buddy.Failure"
    __slots__ = ("error", "stack")
    _hx_fields = ["error", "stack"]

    def __init__(self,error,stack):
        if (error is None):
            raise _HxException("Failure must have an error.")
        self.error = error
        self.stack = ([] if ((stack is None)) else stack)

buddy_Failure._hx_class = buddy_Failure

class buddy_TestFunc(Enum):
    __slots__ = ()
    _hx_class_name = "buddy.TestFunc"
    _hx_constructs = ["Async", "Sync"]

    @staticmethod
    def Async(f):
        return buddy_TestFunc("Async", 0, [f])

    @staticmethod
    def Sync(f):
        return buddy_TestFunc("Sync", 1, [f])
buddy_TestFunc._hx_class = buddy_TestFunc

class buddy_TestSpec(Enum):
    __slots__ = ()
    _hx_class_name = "buddy.TestSpec"
    _hx_constructs = ["Describe", "It"]

    @staticmethod
    def Describe(suite,included):
        return buddy_TestSpec("Describe", 0, [suite,included])

    @staticmethod
    def It(description,test,included,pos,time):
        return buddy_TestSpec("It", 1, [description,test,included,pos,time])
buddy_TestSpec._hx_class = buddy_TestSpec


class buddy_TestSuite:
    _hx_class_name = "buddy.TestSuite"
    __slots__ = ("description", "beforeAll", "beforeEach", "specs", "afterEach", "afterAll")
    _hx_fields = ["description", "beforeAll", "beforeEach", "specs", "afterEach", "afterAll"]

    def __init__(self,description):
        self.afterAll = haxe_ds_List()
        self.afterEach = haxe_ds_List()
        self.specs = haxe_ds_List()
        self.beforeEach = haxe_ds_List()
        self.beforeAll = haxe_ds_List()
        if (description is None):
            raise _HxException("TestSuite must have a description. Can be empty.")
        self.description = description

buddy_TestSuite._hx_class = buddy_TestSuite


class buddy_Should:
    _hx_class_name = "buddy.Should"
    __slots__ = ("value", "inverse")
    _hx_fields = ["value", "inverse"]
    _hx_methods = ["be", "beType", "quote", "fail", "test"]

    def __init__(self,value,inverse = False):
        if (inverse is None):
            inverse = False
        self.value = value
        self.inverse = inverse

    def be(self,expected,p = None):
        result = ((python_lib_Builtins.id(self.value) == python_lib_Builtins.id(expected)) if ((isinstance(self.value,list) and isinstance(expected,list))) else HxOverrides.eq(self.value,expected))
        self.test(result,p,((("Expected " + HxOverrides.stringOrNull(self.quote(expected))) + ", was ") + HxOverrides.stringOrNull(self.quote(self.value))),(("Didn't expect " + HxOverrides.stringOrNull(self.quote(expected))) + " but was equal to that"))

    def beType(self,_hx_type,p = None):
        self.test(Std._hx_is(self.value,_hx_type),p,((("Expected " + HxOverrides.stringOrNull(self.quote(self.value))) + " to be type ") + HxOverrides.stringOrNull(self.quote(_hx_type))),((("Expected " + HxOverrides.stringOrNull(self.quote(self.value))) + " not to be type ") + HxOverrides.stringOrNull(self.quote(_hx_type))))

    def quote(self,v):
        if Std._hx_is(v,str):
            return (("\"" + Std.string(v)) + "\"")
        if Std._hx_is(v,haxe_ds_List):
            return Std.string(Lambda.array(v))
        return Std.string(v)

    def fail(self,error,errorInverted,p):
        tmp = (errorInverted if (self.inverse) else error)
        tmp1 = buddy_SuitesRunner.posInfosToStack(p)
        buddy_SuitesRunner.currentTest(False,tmp,tmp1)

    def test(self,expr,p,error,errorInverted):
        if (buddy_SuitesRunner.currentTest is None):
            raise _HxException("SuitesRunner.currentTest was null")
        if (not self.inverse):
            tmp = buddy_SuitesRunner.posInfosToStack(p)
            buddy_SuitesRunner.currentTest(expr,error,tmp)
        else:
            tmp1 = buddy_SuitesRunner.posInfosToStack(p)
            buddy_SuitesRunner.currentTest((not expr),errorInverted,tmp1)

buddy_Should._hx_class = buddy_Should


class buddy_ShouldDynamic(buddy_Should):
    _hx_class_name = "buddy.ShouldDynamic"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["get_not"]
    _hx_statics = ["should"]
    _hx_interfaces = []
    _hx_super = buddy_Should


    def __init__(self,value,inverse = None):
        super().__init__(value,inverse)

    def get_not(self):
        return buddy_ShouldDynamic(self.value,(not self.inverse))

    @staticmethod
    def should(d):
        return buddy_ShouldDynamic(d)

buddy_ShouldDynamic._hx_class = buddy_ShouldDynamic


class buddy_ShouldEnum(buddy_Should):
    _hx_class_name = "buddy.ShouldEnum"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["get_not", "be", "equal"]
    _hx_statics = ["should"]
    _hx_interfaces = []
    _hx_super = buddy_Should


    def __init__(self,value,inverse = False):
        if (inverse is None):
            inverse = False
        super().__init__(value,inverse)

    def get_not(self):
        return buddy_ShouldEnum(self.value,(not self.inverse))

    def be(self,expected,p = None):
        self.equal(expected,p)

    def equal(self,expected,p = None):
        self.test(Type.enumEq(self.value,expected),p,((("Expected " + HxOverrides.stringOrNull(self.quote(expected))) + ", was ") + HxOverrides.stringOrNull(self.quote(self.value))),(("Didn't expect " + HxOverrides.stringOrNull(self.quote(self.value))) + " but was equal to that"))

    @staticmethod
    def should(e):
        return buddy_ShouldEnum(e)

buddy_ShouldEnum._hx_class = buddy_ShouldEnum


class buddy_ShouldInt(buddy_Should):
    _hx_class_name = "buddy.ShouldInt"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["get_not", "beLessThan", "beGreaterThan"]
    _hx_statics = ["should"]
    _hx_interfaces = []
    _hx_super = buddy_Should


    def __init__(self,value,inverse = False):
        if (inverse is None):
            inverse = False
        super().__init__(value,inverse)

    def get_not(self):
        return buddy_ShouldInt(self.value,(not self.inverse))

    def beLessThan(self,expected,p = None):
        self.test((self.value < expected),p,((("Expected less than " + HxOverrides.stringOrNull(self.quote(expected))) + ", was ") + HxOverrides.stringOrNull(self.quote(self.value))),((("Expected not less than " + HxOverrides.stringOrNull(self.quote(expected))) + ", was ") + HxOverrides.stringOrNull(self.quote(self.value))))

    def beGreaterThan(self,expected,p = None):
        self.test((self.value > expected),p,((("Expected greater than " + HxOverrides.stringOrNull(self.quote(expected))) + ", was ") + HxOverrides.stringOrNull(self.quote(self.value))),((("Expected not greater than " + HxOverrides.stringOrNull(self.quote(expected))) + ", was ") + HxOverrides.stringOrNull(self.quote(self.value))))

    @staticmethod
    def should(i):
        return buddy_ShouldInt(i)

buddy_ShouldInt._hx_class = buddy_ShouldInt


class buddy_ShouldInt64(buddy_Should):
    _hx_class_name = "buddy.ShouldInt64"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["get_not", "be", "beLessThan", "beGreaterThan"]
    _hx_statics = ["should"]
    _hx_interfaces = []
    _hx_super = buddy_Should


    def __init__(self,value,inverse = False):
        if (inverse is None):
            inverse = False
        super().__init__(value,inverse)

    def get_not(self):
        return buddy_ShouldInt64(self.value,(not self.inverse))

    def be(self,expected,p = None):
        b = self.value
        v = (((expected.high - b.high) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
        v = (v if ((v != 0)) else haxe__Int32_Int32_Impl_.ucompare(expected.low,b.low))
        result = ((((v if ((b.high < 0)) else -1) if ((expected.high < 0)) else (v if ((b.high >= 0)) else 1))) == 0)
        self.test(result,p,((("Expected " + HxOverrides.stringOrNull(self.quote(expected))) + ", was ") + HxOverrides.stringOrNull(self.quote(self.value))),(("Didn't expect " + HxOverrides.stringOrNull(self.quote(expected))) + " but was equal to that"))

    def beLessThan(self,expected,p = None):
        a = self.value
        v = (((a.high - expected.high) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
        v = (v if ((v != 0)) else haxe__Int32_Int32_Impl_.ucompare(a.low,expected.low))
        self.test(((((v if ((expected.high < 0)) else -1) if ((a.high < 0)) else (v if ((expected.high >= 0)) else 1))) < 0),p,((("Expected less than " + HxOverrides.stringOrNull(self.quote(expected))) + ", was ") + HxOverrides.stringOrNull(self.quote(self.value))),((("Expected not less than " + HxOverrides.stringOrNull(self.quote(expected))) + ", was ") + HxOverrides.stringOrNull(self.quote(self.value))))

    def beGreaterThan(self,expected,p = None):
        a = self.value
        v = (((a.high - expected.high) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
        v = (v if ((v != 0)) else haxe__Int32_Int32_Impl_.ucompare(a.low,expected.low))
        self.test(((((v if ((expected.high < 0)) else -1) if ((a.high < 0)) else (v if ((expected.high >= 0)) else 1))) > 0),p,((("Expected greater than " + HxOverrides.stringOrNull(self.quote(expected))) + ", was ") + HxOverrides.stringOrNull(self.quote(self.value))),((("Expected not greater than " + HxOverrides.stringOrNull(self.quote(expected))) + ", was ") + HxOverrides.stringOrNull(self.quote(self.value))))

    @staticmethod
    def should(i):
        return buddy_ShouldInt64(i)

buddy_ShouldInt64._hx_class = buddy_ShouldInt64


class buddy_ShouldFloat(buddy_Should):
    _hx_class_name = "buddy.ShouldFloat"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["get_not", "beLessThan", "beGreaterThan", "beCloseTo"]
    _hx_statics = ["should"]
    _hx_interfaces = []
    _hx_super = buddy_Should


    def __init__(self,value,inverse = False):
        if (inverse is None):
            inverse = False
        super().__init__(value,inverse)

    def get_not(self):
        return buddy_ShouldFloat(self.value,(not self.inverse))

    def beLessThan(self,expected,p = None):
        self.test((self.value < expected),p,((("Expected less than " + HxOverrides.stringOrNull(self.quote(expected))) + ", was ") + HxOverrides.stringOrNull(self.quote(self.value))),((("Expected not less than " + HxOverrides.stringOrNull(self.quote(expected))) + ", was ") + HxOverrides.stringOrNull(self.quote(self.value))))

    def beGreaterThan(self,expected,p = None):
        self.test((self.value > expected),p,((("Expected greater than " + HxOverrides.stringOrNull(self.quote(expected))) + ", was ") + HxOverrides.stringOrNull(self.quote(self.value))),((("Expected not greater than " + HxOverrides.stringOrNull(self.quote(expected))) + ", was ") + HxOverrides.stringOrNull(self.quote(self.value))))

    def beCloseTo(self,expected,precision = 2,p = None):
        if (precision is None):
            precision = 2
        diff = Reflect.field(Math,"fabs")((expected - self.value))
        threshold = (Math.pow(10,-precision) / 2)
        expr = (diff < threshold)
        self.test(expr,p,((("Expected close to " + HxOverrides.stringOrNull(self.quote(expected))) + ", was ") + HxOverrides.stringOrNull(self.quote(self.value))),((("Expected " + HxOverrides.stringOrNull(self.quote(self.value))) + " not to be close to ") + HxOverrides.stringOrNull(self.quote(expected))))

    @staticmethod
    def should(i):
        return buddy_ShouldFloat(i)

buddy_ShouldFloat._hx_class = buddy_ShouldFloat


class buddy_ShouldDate(buddy_Should):
    _hx_class_name = "buddy.ShouldDate"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["get_not", "beOn", "beBefore", "beAfter", "beOnStr", "beBeforeStr", "beAfterStr"]
    _hx_statics = ["should"]
    _hx_interfaces = []
    _hx_super = buddy_Should


    def __init__(self,value,inverse = False):
        if (inverse is None):
            inverse = False
        super().__init__(value,inverse)

    def get_not(self):
        return buddy_ShouldDate(self.value,(not self.inverse))

    def beOn(self,expected,p = None):
        self.test(((python_lib_Time.mktime(self.value.date.timetuple()) * 1000) == ((python_lib_Time.mktime(expected.date.timetuple()) * 1000))),p,((("Expected date equal to " + HxOverrides.stringOrNull(self.quote(expected))) + ", was ") + HxOverrides.stringOrNull(self.quote(self.value))),("Expected date not equal to " + HxOverrides.stringOrNull(self.quote(expected))))

    def beBefore(self,expected,p = None):
        self.test(((python_lib_Time.mktime(self.value.date.timetuple()) * 1000) < ((python_lib_Time.mktime(expected.date.timetuple()) * 1000))),p,((("Expected date before " + HxOverrides.stringOrNull(self.quote(expected))) + ", was ") + HxOverrides.stringOrNull(self.quote(self.value))),((("Expected date not before " + HxOverrides.stringOrNull(self.quote(expected))) + ", was ") + HxOverrides.stringOrNull(self.quote(self.value))))

    def beAfter(self,expected,p = None):
        self.test(((python_lib_Time.mktime(self.value.date.timetuple()) * 1000) > ((python_lib_Time.mktime(expected.date.timetuple()) * 1000))),p,((("Expected date after " + HxOverrides.stringOrNull(self.quote(expected))) + ", was ") + HxOverrides.stringOrNull(self.quote(self.value))),((("Expected date not after " + HxOverrides.stringOrNull(self.quote(expected))) + ", was ") + HxOverrides.stringOrNull(self.quote(self.value))))

    def beOnStr(self,expected,p = None):
        self.beOn(Date.fromString(expected),p)
        return

    def beBeforeStr(self,expected,p = None):
        self.beBefore(Date.fromString(expected),p)
        return

    def beAfterStr(self,expected,p = None):
        self.beAfter(Date.fromString(expected),p)
        return

    @staticmethod
    def should(i):
        return buddy_ShouldDate(i)

buddy_ShouldDate._hx_class = buddy_ShouldDate


class buddy_ShouldIterable(buddy_Should):
    _hx_class_name = "buddy.ShouldIterable"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["get_not", "contain", "containAll", "containExactly"]
    _hx_statics = ["should"]
    _hx_interfaces = []
    _hx_super = buddy_Should


    def __init__(self,value,inverse = False):
        if (inverse is None):
            inverse = False
        super().__init__(value,inverse)

    def get_not(self):
        return buddy_ShouldIterable(self.value,(not self.inverse))

    def contain(self,o,p = None):
        def _hx_local_0(el):
            return HxOverrides.eq(el,o)
        self.test(Lambda.exists(self.value,_hx_local_0),p,((("Expected " + HxOverrides.stringOrNull(self.quote(self.value))) + " to contain ") + HxOverrides.stringOrNull(self.quote(o))),((("Expected " + HxOverrides.stringOrNull(self.quote(self.value))) + " not to contain ") + HxOverrides.stringOrNull(self.quote(o))))

    def containAll(self,values,p = None):
        expr = True
        a = HxOverrides.iterator(values)
        while a.hasNext():
            a1 = a.next()
            a2 = [a1]
            def _hx_local_1(a3):
                def _hx_local_0(v):
                    return HxOverrides.eq(v,(a3[0] if 0 < len(a3) else None))
                return _hx_local_0
            if (not Lambda.exists(self.value,_hx_local_1(a2))):
                expr = False
                break
        self.test(expr,p,((("Expected " + HxOverrides.stringOrNull(self.quote(self.value))) + " to contain all of ") + HxOverrides.stringOrNull(self.quote(values))),((("Expected " + HxOverrides.stringOrNull(self.quote(self.value))) + " not to contain all of ") + HxOverrides.stringOrNull(self.quote(values))))

    def containExactly(self,values,p = None):
        a = HxOverrides.iterator(self.value)
        b = HxOverrides.iterator(values)
        expr = True
        while (a.hasNext() or b.hasNext()):
            if not HxOverrides.eq(a.next(),b.next()):
                expr = False
                break
        self.test(expr,p,((("Expected " + HxOverrides.stringOrNull(self.quote(self.value))) + " to contain exactly ") + HxOverrides.stringOrNull(self.quote(values))),((("Expected " + HxOverrides.stringOrNull(self.quote(self.value))) + " not to contain exactly ") + HxOverrides.stringOrNull(self.quote(values))))

    @staticmethod
    def should(value):
        return buddy_ShouldIterable(value)

buddy_ShouldIterable._hx_class = buddy_ShouldIterable


class buddy_ShouldString(buddy_Should):
    _hx_class_name = "buddy.ShouldString"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["get_not", "contain", "startWith", "endWith", "match"]
    _hx_statics = ["should"]
    _hx_interfaces = []
    _hx_super = buddy_Should


    def __init__(self,value,inverse = False):
        if (inverse is None):
            inverse = False
        super().__init__(value,inverse)

    def get_not(self):
        return buddy_ShouldString(self.value,(not self.inverse))

    def contain(self,substring,p = None):
        if (self.value is None):
            self.fail((("Expected string to contain " + HxOverrides.stringOrNull(self.quote(substring))) + " but string was null"),(("Expected string not to contain " + HxOverrides.stringOrNull(self.quote(substring))) + " but string was null"),p)
            return
        _this = self.value
        self.test((_this.find(substring) >= 0),p,((("Expected " + HxOverrides.stringOrNull(self.quote(self.value))) + " to contain ") + HxOverrides.stringOrNull(self.quote(substring))),((("Expected " + HxOverrides.stringOrNull(self.quote(self.value))) + " not to contain ") + HxOverrides.stringOrNull(self.quote(substring))))

    def startWith(self,substring,p = None):
        if (self.value is None):
            self.fail((("Expected string to start with " + HxOverrides.stringOrNull(self.quote(substring))) + " but string was null"),(("Expected string not to start with " + HxOverrides.stringOrNull(self.quote(substring))) + " but string was null"),p)
            return
        self.test(self.value.startswith(substring),p,((("Expected " + HxOverrides.stringOrNull(self.quote(self.value))) + " to start with ") + HxOverrides.stringOrNull(self.quote(substring))),((("Expected " + HxOverrides.stringOrNull(self.quote(self.value))) + " not to start with ") + HxOverrides.stringOrNull(self.quote(substring))))

    def endWith(self,substring,p = None):
        if (self.value is None):
            self.fail((("Expected string to end with " + HxOverrides.stringOrNull(self.quote(substring))) + " but string was null"),(("Expected string not to end with " + HxOverrides.stringOrNull(self.quote(substring))) + " but string was null"),p)
            return
        self.test(self.value.endswith(substring),p,((("Expected " + HxOverrides.stringOrNull(self.quote(self.value))) + " to end with ") + HxOverrides.stringOrNull(self.quote(substring))),((("Expected " + HxOverrides.stringOrNull(self.quote(self.value))) + " not to end with ") + HxOverrides.stringOrNull(self.quote(substring))))

    def match(self,regexp,p = None):
        if (self.value is None):
            self.fail("Expected string to match regular expression but string was null","Expected string not to match regular expression but string was null",p)
            return
        regexp.matchObj = python_lib_Re.search(regexp.pattern,self.value)
        self.test((regexp.matchObj is not None),p,(("Expected " + HxOverrides.stringOrNull(self.quote(self.value))) + " to match regular expression"),(("Expected " + HxOverrides.stringOrNull(self.quote(self.value))) + " not to match regular expression"))

    @staticmethod
    def should(_hx_str):
        return buddy_ShouldString(_hx_str)

buddy_ShouldString._hx_class = buddy_ShouldString


class buddy_ShouldFunctions:
    _hx_class_name = "buddy.ShouldFunctions"
    __slots__ = ("value", "inverse")
    _hx_fields = ["value", "inverse"]
    _hx_methods = ["get_not", "throwAnything", "throwValue", "throwType", "be", "quote", "test"]
    _hx_statics = ["should"]

    def __init__(self,value,inverse = False):
        if (inverse is None):
            inverse = False
        self.value = value
        self.inverse = inverse

    def get_not(self):
        return buddy_ShouldFunctions(self.value,(not self.inverse))

    def throwAnything(self,p = None):
        caught = False
        exception = None
        try:
            self.value()
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e = _hx_e1
            exception = e
            caught = True
        self.test(caught,p,(("Expected " + HxOverrides.stringOrNull(self.quote(self.value))) + " to throw anything, nothing was thrown"),(((("Expected " + HxOverrides.stringOrNull(self.quote(self.value))) + " not to throw anything, ") + HxOverrides.stringOrNull(self.quote(exception))) + " was thrown"))
        return exception

    def throwValue(self,v,p = None):
        exception = None
        try:
            self.value()
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e = _hx_e1
            cause = None
            exception = (e if ((cause is None)) else cause)
        isCaught = HxOverrides.eq(exception,v)
        self.test(isCaught,p,((("Expected " + HxOverrides.stringOrNull(self.quote(self.value))) + " to throw ") + HxOverrides.stringOrNull(self.quote(v))),((("Expected " + HxOverrides.stringOrNull(self.quote(self.value))) + " not to throw ") + HxOverrides.stringOrNull(self.quote(v))))
        return exception

    def throwType(self,_hx_type,p = None):
        exception = None
        try:
            self.value()
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e = _hx_e1
            cause = None
            exception = (e if ((cause is None)) else cause)
        typeName = Type.getClassName(_hx_type)
        exceptionName = (None if ((exception is None)) else Type.getClassName(Type.getClass(exception)))
        if (exceptionName is None):
            exceptionName = "no exception"
        isCaught = Std._hx_is(exception,_hx_type)
        self.test(isCaught,p,(((((("Expected " + HxOverrides.stringOrNull(self.quote(self.value))) + " to throw type ") + ("null" if typeName is None else typeName)) + ", ") + ("null" if exceptionName is None else exceptionName)) + " was thrown instead"),((("Expected " + HxOverrides.stringOrNull(self.quote(self.value))) + " not to throw type ") + ("null" if typeName is None else typeName)))
        return exception

    def be(self,expected,p = None):
        self.test((self.value == expected),p,((("Expected " + HxOverrides.stringOrNull(self.quote(expected))) + ", was ") + HxOverrides.stringOrNull(self.quote(self.value))),(("Didn't expect " + HxOverrides.stringOrNull(self.quote(expected))) + " but was equal to that"))

    def quote(self,v):
        if Std._hx_is(v,str):
            return (("\"" + Std.string(v)) + "\"")
        if Std._hx_is(v,haxe_ds_List):
            return Std.string(Lambda.array(v))
        return Std.string(v)

    def test(self,expr,p,error,errorInverted):
        if (buddy_SuitesRunner.currentTest is None):
            raise _HxException("SuitesRunner.currentTest was null")
        if (not self.inverse):
            tmp = buddy_SuitesRunner.posInfosToStack(p)
            buddy_SuitesRunner.currentTest(expr,error,tmp)
        else:
            tmp1 = buddy_SuitesRunner.posInfosToStack(p)
            buddy_SuitesRunner.currentTest((not expr),errorInverted,tmp1)

    @staticmethod
    def should(value):
        return buddy_ShouldFunctions(value)

buddy_ShouldFunctions._hx_class = buddy_ShouldFunctions


class buddy_SuitesRunner:
    _hx_class_name = "buddy.SuitesRunner"
    __slots__ = ("unrecoverableError", "unrecoverableErrorStack", "allTestsPassed", "buddySuites", "reporter", "runCompleted", "includeMode", "oldLog")
    _hx_fields = ["unrecoverableError", "unrecoverableErrorStack", "allTestsPassed", "buddySuites", "reporter", "runCompleted", "includeMode", "oldLog"]
    _hx_methods = ["run", "runDescribes", "failed", "statusCode", "startRun", "startIncludeMode", "mapTestSuite", "runTestFuncs", "flatten", "isSync", "mapTestSpec", "haveUnrecoverableError"]
    _hx_statics = ["currentTest", "posInfosToStack"]

    def __init__(self,buddySuites,reporter = None):
        self.includeMode = None
        self.runCompleted = None
        self.allTestsPassed = False
        self.unrecoverableErrorStack = None
        self.unrecoverableError = None
        self.buddySuites = buddySuites
        self.reporter = (buddy_reporting_ConsoleReporter() if ((reporter is None)) else reporter)
        self.oldLog = haxe_Log.trace
        def _hx_local_0(suite):
            metaData = haxe_rtti_Meta.getType(Type.getClass(suite))
            return hasattr(metaData,(("_hx_" + "includeMode") if (("includeMode" in python_Boot.keywords)) else (("_hx_" + "includeMode") if (((((len("includeMode") > 2) and ((ord("includeMode"[0]) == 95))) and ((ord("includeMode"[1]) == 95))) and ((ord("includeMode"[(len("includeMode") - 1)]) != 95)))) else "includeMode")))
        self.includeMode = Lambda.exists(buddySuites,_hx_local_0)

    def run(self):
        _gthis = self
        buddy_PythonSys.setrecursionlimit(100000)
        self.runCompleted = promhx_Deferred()
        runCompletedPromise = self.runCompleted.promise()
        def _hx_local_0(err):
            if (err is not None):
                _gthis.haveUnrecoverableError(err)
                return
            if _gthis.includeMode:
                _gthis.startIncludeMode()
            _gthis.startRun()
        self.runDescribes(_hx_local_0)
        return runCompletedPromise

    def runDescribes(self,cb):
        _gthis = self
        asyncQueue = list()
        syncQueue = list()
        def _hx_local_0(suite):
            while (not Lambda.empty(suite.describeQueue)):
                _this = suite.describeQueue
                current = (None if ((len(_this) == 0)) else _this.pop())
                _g = current.spec
                processSuiteDescribes1 = _g.index
                if (processSuiteDescribes1 == 0):
                    f = _g.params[0]
                    x = _hx_AnonObject({'buddySuite': suite, 'testSuite': current.suite, 'run': f})
                    asyncQueue.append(x)
                elif (processSuiteDescribes1 == 1):
                    f1 = _g.params[0]
                    x1 = _hx_AnonObject({'buddySuite': suite, 'testSuite': current.suite, 'run': f1})
                    syncQueue.append(x1)
                else:
                    pass
        processSuiteDescribes = _hx_local_0
        processBuddySuites = None
        def _hx_local_5():
            nonlocal syncQueue
            buddySuite = HxOverrides.iterator(_gthis.buddySuites)
            while buddySuite.hasNext():
                buddySuite1 = buddySuite.next()
                processSuiteDescribes(buddySuite1)
            if (len(syncQueue) > 0):
                try:
                    _g1 = 0
                    while (_g1 < len(syncQueue)):
                        test = (syncQueue[_g1] if _g1 >= 0 and _g1 < len(syncQueue) else None)
                        _g1 = (_g1 + 1)
                        test.buddySuite.currentSuite = test.testSuite
                        test.run()
                except Exception as _hx_e:
                    _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                    err = _hx_e1
                    cb(err)
                    return
                syncQueue = []
                processBuddySuites()
            elif (len(asyncQueue) > 0):
                def _hx_local_3(test1,cb1):
                    test1.buddySuite.currentSuite = test1.testSuite
                    def _hx_local_2():
                        cb1(None)
                    test1.run(_hx_local_2)
                def _hx_local_4(err1):
                    nonlocal asyncQueue
                    if (err1 is not None):
                        cb(err1)
                        return
                    asyncQueue = []
                    processBuddySuites()
                AsyncTools.aEachSeries(asyncQueue,_hx_local_3,_hx_local_4)
            else:
                cb(None)
        processBuddySuites = _hx_local_5
        processBuddySuites()

    def failed(self):
        return (not self.allTestsPassed)

    def statusCode(self):
        if self.failed():
            return 1
        else:
            return 0

    def startRun(self):
        _gthis = self
        r = self.reporter.start()
        def _hx_local_6(go):
            if (not go):
                r1 = _gthis.reporter.done([],False)
                def _hx_local_0(_):
                    _gthis.runCompleted.resolve(_gthis)
                r1.then(_hx_local_0)
                return
            beforeEachStack = [[]]
            afterEachStack = [[]]
            def _hx_local_2(buddySuite,done):
                def _hx_local_1(err,suite):
                    if ((err is None) and ((suite is None))):
                        return
                    if (err is not None):
                        suite.error = err
                        suite.stack = haxe_CallStack.exceptionStack()
                    done(err,suite)
                suiteDone = _hx_local_1
                syncSuite = _gthis.mapTestSuite(buddySuite,buddySuite.suite,beforeEachStack,afterEachStack,suiteDone)
                if (syncSuite is not None):
                    suiteDone(syncSuite.error,syncSuite.suite)
            def _hx_local_5(err1,suites):
                if (err1 is not None):
                    _gthis.haveUnrecoverableError(err1)
                else:
                    def _hx_local_3(suite1):
                        return (not suite1.passed())
                    _gthis.allTestsPassed = (not Lambda.exists(suites,_hx_local_3))
                    r2 = _gthis.reporter.done(suites,_gthis.allTestsPassed)
                    def _hx_local_4(_1):
                        _gthis.runCompleted.resolve(_gthis)
                    r2.then(_hx_local_4)
            AsyncTools.aMapSeries(_gthis.buddySuites,_hx_local_2,_hx_local_5)
        r.then(_hx_local_6)

    def startIncludeMode(self):
        traverse = None
        def _hx_local_1(suite):
            def _hx_local_0(spec):
                traverse1 = spec.index
                if (traverse1 == 0):
                    included = spec.params[1]
                    suite1 = spec.params[0]
                    if included:
                        return True
                    else:
                        return traverse(suite1)
                elif (traverse1 == 1):
                    included1 = spec.params[2]
                    desc = spec.params[0]
                    return included1
                else:
                    pass
            suite.specs = suite.specs.filter(_hx_local_0)
            return (suite.specs.length > 0)
        traverse = _hx_local_1
        def _hx_local_2(buddySuite):
            suiteMeta = haxe_rtti_Meta.getType(Type.getClass(buddySuite))
            if hasattr(suiteMeta,(("_hx_" + "include") if (("include" in python_Boot.keywords)) else (("_hx_" + "include") if (((((len("include") > 2) and ((ord("include"[0]) == 95))) and ((ord("include"[1]) == 95))) and ((ord("include"[(len("include") - 1)]) != 95)))) else "include"))):
                return True
            return traverse(buddySuite.suite)
        self.buddySuites = Lambda.filter(self.buddySuites,_hx_local_2)

    def mapTestSuite(self,buddySuite,testSuite,beforeEachStack,afterEachStack,done):
        _gthis = self
        def _hx_local_0():
            buddy_tests_SelfTest.lastSuite = buddy_Suite(testSuite.description)
            return buddy_tests_SelfTest.lastSuite
        currentSuite = _hx_local_0()
        x = Lambda.array(testSuite.beforeEach)
        beforeEachStack.append(x)
        x1 = Lambda.array(testSuite.afterEach)
        afterEachStack.insert(0, x1)
        allSync = (self.isSync(testSuite.beforeAll) and self.isSync(testSuite.afterAll))
        result = None
        syncResultCount = 0
        def _hx_local_5(err):
            nonlocal result
            if (err is not None):
                if _gthis.isSync(testSuite.beforeAll):
                    result = _hx_AnonObject({'error': err, 'suite': currentSuite})
                else:
                    done(err,currentSuite)
                return
            def _hx_local_2(testSpec,cb):
                nonlocal syncResultCount
                result2 = _gthis.mapTestSpec(buddySuite,testSuite,beforeEachStack,afterEachStack,testSpec,cb)
                if (result2 is not None):
                    syncResultCount = (syncResultCount + 1)
                    cb(result2.error,result2.step)
            def _hx_local_4(err1,testSteps):
                nonlocal allSync
                nonlocal result
                allSync = (allSync and ((len(testSteps) == syncResultCount)))
                if (err1 is not None):
                    if allSync:
                        result = _hx_AnonObject({'error': err1, 'suite': currentSuite})
                    else:
                        done(err1,currentSuite)
                    return
                def _hx_local_3(err2):
                    nonlocal result
                    nonlocal result
                    if (err2 is not None):
                        if allSync:
                            result = _hx_AnonObject({'error': err2, 'suite': currentSuite})
                        else:
                            done(err2,currentSuite)
                        return
                    currentSuite.steps = testSteps
                    if (len(beforeEachStack) != 0):
                        beforeEachStack.pop()
                    if (len(afterEachStack) != 0):
                        afterEachStack.pop(0)
                    if allSync:
                        result = _hx_AnonObject({'error': None, 'suite': currentSuite})
                    else:
                        done(None,currentSuite)
                _gthis.runTestFuncs(testSuite.afterAll,_hx_local_3)
            AsyncTools.aMapSeries(testSuite.specs,_hx_local_2,_hx_local_4)
        self.runTestFuncs(testSuite.beforeAll,_hx_local_5)
        if (result is not None):
            done(None,None)
        return result

    def runTestFuncs(self,funcs,done):
        syncQ = []
        asyncQ = []
        func = HxOverrides.iterator(funcs)
        while func.hasNext():
            func1 = func.next()
            tmp = func1.index
            if (tmp == 0):
                f = func1.params[0]
                asyncQ.append(f)
            elif (tmp == 1):
                f1 = func1.params[0]
                syncQ.append(f1)
            else:
                pass
        try:
            _g = 0
            while (_g < len(syncQ)):
                f2 = (syncQ[_g] if _g >= 0 and _g < len(syncQ) else None)
                _g = (_g + 1)
                f2()
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            err = _hx_e1
            done(err)
            return
        def _hx_local_2(f3,done1):
            def _hx_local_1():
                done1()
            f3(_hx_local_1)
        AsyncTools.aEachSeries(asyncQ,_hx_local_2,done)

    def flatten(self,arr):
        _g = []
        _g1 = 0
        while (_g1 < len(arr)):
            a = (arr[_g1] if _g1 >= 0 and _g1 < len(arr) else None)
            _g1 = (_g1 + 1)
            _g11 = 0
            while (_g11 < len(a)):
                b = (a[_g11] if _g11 >= 0 and _g11 < len(a) else None)
                _g11 = (_g11 + 1)
                _g.append(b)
        return _g

    def isSync(self,funcs):
        f = HxOverrides.iterator(funcs)
        while f.hasNext():
            f1 = f.next()
            if (f1.index == 0):
                return False
        return True

    def mapTestSpec(self,buddySuite,testSuite,beforeEachStack,afterEachStack,testSpec,done):
        _gthis = self
        hasCompleted = False
        oldFail = None
        def _hx_local_1():
            def _hx_local_0(err = "Exception",p = None):
                if (err is None):
                    err = "Exception"
                if ((not hasCompleted) and ((oldFail == buddySuite.fail))):
                    done(err,None)
            buddySuite.fail = _hx_local_0
            return buddySuite.fail
        oldFail = _hx_local_1()
        def _hx_local_3():
            def _hx_local_2(message = None,p1 = None):
                done("Cannot call pending here.",None)
            buddySuite.pending = _hx_local_2
            return buddySuite.pending
        oldPending = _hx_local_3()
        tmp = testSpec.index
        if (tmp == 0):
            testSuite1 = testSpec.params[0]
            def _hx_local_4(err1,newSuite):
                if ((err1 is None) and ((newSuite is None))):
                    return
                if (err1 is not None):
                    done(err1,None)
                else:
                    done(None,buddy_Step.TSuite(newSuite))
            result = self.mapTestSuite(buddySuite,testSuite1,beforeEachStack,afterEachStack,_hx_local_4)
            if (result is not None):
                return _hx_AnonObject({'error': result.error, 'step': buddy_Step.TSuite(result.suite)})
            else:
                return None
        elif (tmp == 1):
            time = testSpec.params[4]
            pos = testSpec.params[3]
            test = testSpec.params[1]
            desc = testSpec.params[0]
            def _hx_local_5():
                buddy_tests_SelfTest.lastSpec = buddy_Spec(desc,pos.fileName)
                return buddy_tests_SelfTest.lastSpec
            spec = _hx_local_5()
            beforeEach = self.flatten(beforeEachStack)
            afterEach = self.flatten(afterEachStack)
            eachIsSync = (self.isSync(beforeEach) and self.isSync(afterEach))
            returnSync = None
            if (test is None):
                returnSync = eachIsSync
            else:
                returnSync1 = test.index
                if (returnSync1 == 0):
                    returnSync = False
                elif (returnSync1 == 1):
                    returnSync = eachIsSync
                else:
                    pass
            if (not buddy_BuddySuite.useDefaultTrace):
                def _hx_local_7(v,pos1 = None):
                    if (pos1 is None):
                        _this = spec.traces
                        x = Std.string(v)
                        _this.append(x)
                    else:
                        output = None
                        if (Reflect.field(pos1,"customParams") is not None):
                            output1 = (Std.string(v) + ",")
                            def _hx_local_6(v2):
                                return Std.string(v2)
                            _this1 = list(map(_hx_local_6,Reflect.field(pos1,"customParams")))
                            output = (("null" if output1 is None else output1) + HxOverrides.stringOrNull(",".join([python_Boot.toString1(x1,'') for x1 in _this1])))
                        else:
                            output = Std.string(v)
                        _this2 = spec.traces
                        x1 = ((((HxOverrides.stringOrNull(pos1.fileName) + ":") + Std.string(pos1.lineNumber)) + ": ") + ("null" if output is None else output))
                        _this2.append(x1)
                haxe_Log.trace = _hx_local_7
            def _hx_local_8(error,stack):
                if hasCompleted:
                    return
                spec.status = buddy_SpecStatus.Failed
                _this3 = spec.failures
                x2 = buddy_Failure(error,stack)
                _this3.append(x2)
            reportFailure = _hx_local_8
            def _hx_local_11(status):
                nonlocal hasCompleted
                if hasCompleted:
                    return None
                hasCompleted = True
                if (spec.status == buddy_SpecStatus.Unknown):
                    spec.status = status
                if (not buddy_BuddySuite.useDefaultTrace):
                    haxe_Log.trace = _gthis.oldLog
                buddySuite.fail = oldFail
                buddySuite.pending = oldPending
                syncResult = None
                def _hx_local_10(err2):
                    nonlocal syncResult
                    if returnSync:
                        syncResult = _hx_AnonObject({'error': err2, 'step': (buddy_Step.TSpec(spec) if ((err2 is None)) else None)})
                        _gthis.reporter.progress(spec)
                    elif (err2 is not None):
                        done(err2,None)
                    else:
                        r = _gthis.reporter.progress(spec)
                        def _hx_local_9(_):
                            done(None,buddy_Step.TSpec(spec))
                        r.then(_hx_local_9)
                _gthis.runTestFuncs(afterEach,_hx_local_10)
                return syncResult
            specCompleted = _hx_local_11
            if (test is None):
                return specCompleted(buddy_SpecStatus.Pending)
            def _hx_local_12(testStatus,error1,stack1):
                if (testStatus != True):
                    reportFailure(error1,stack1)
            buddy_SuitesRunner.currentTest = _hx_local_12
            if ((not returnSync) and ((buddySuite.timeoutMs > 0))):
                r1 = buddy_tools_AsyncTools.wait(buddySuite.timeoutMs)
                def _hx_local_13(e):
                    tmp1 = haxe_CallStack.exceptionStack()
                    reportFailure(e,tmp1)
                    specCompleted(buddy_SpecStatus.Failed)
                r1.catchError(_hx_local_13)
                def _hx_local_14(_1):
                    reportFailure((("Timeout after " + Std.string(buddySuite.timeoutMs)) + " ms"),[])
                    specCompleted(buddy_SpecStatus.Failed)
                r1.then(_hx_local_14)
            _syncResult = None
            _startTime = python_lib_Timeit.default_timer()
            def _hx_local_15(status1):
                nonlocal _syncResult
                if ((not returnSync) or ((_syncResult is not None))):
                    return
                _syncResult = status1
                setSyncResult1 = python_lib_Timeit.default_timer()
                spec.time = (setSyncResult1 - _startTime)
            setSyncResult = _hx_local_15
            def _hx_local_16(err3 = "Manually",p2 = None):
                if (err3 is None):
                    err3 = "Manually"
                tmp2 = buddy_SuitesRunner.posInfosToStack(p2)
                reportFailure(err3,tmp2)
                tmp3 = specCompleted(buddy_SpecStatus.Failed)
                setSyncResult(tmp3)
            buddySuite.fail = _hx_local_16
            def _hx_local_17(message1 = None,p3 = None):
                msg = (((HxOverrides.stringOrNull(p3.fileName) + ":") + Std.string(p3.lineNumber)) + HxOverrides.stringOrNull((((": " + ("null" if message1 is None else message1)) if ((message1 is not None)) else ""))))
                _this4 = spec.traces
                _this4.append(msg)
                tmp4 = specCompleted(buddy_SpecStatus.Pending)
                setSyncResult(tmp4)
            buddySuite.pending = _hx_local_17
            def _hx_local_21(err4):
                if (err4 is not None):
                    if returnSync:
                        setSyncResult(_hx_AnonObject({'error': err4, 'step': None}))
                    else:
                        done(err4,None)
                    return
                def _hx_local_19(func,done1):
                    try:
                        runTestFunc1 = func.index
                        if (runTestFunc1 == 0):
                            f = func.params[0]
                            def _hx_local_18():
                                done1(None)
                            f(_hx_local_18)
                        elif (runTestFunc1 == 1):
                            f1 = func.params[0]
                            f1()
                            done1(None)
                        else:
                            pass
                    except Exception as _hx_e:
                        _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                        e1 = _hx_e1
                        done1(e1)
                runTestFunc = _hx_local_19
                def _hx_local_20(err5):
                    if (err5 is not None):
                        tmp5 = haxe_CallStack.exceptionStack()
                        reportFailure(err5,tmp5)
                        tmp6 = specCompleted(buddy_SpecStatus.Failed)
                        setSyncResult(tmp6)
                    else:
                        tmp7 = specCompleted(buddy_SpecStatus.Passed)
                        setSyncResult(tmp7)
                runTestFunc(test,_hx_local_20)
            self.runTestFuncs(beforeEach,_hx_local_21)
            return _syncResult
        else:
            pass

    def haveUnrecoverableError(self,err):
        self.unrecoverableError = err
        self.unrecoverableErrorStack = haxe_CallStack.exceptionStack()
        self.runCompleted.resolve(self)
    currentTest = None

    @staticmethod
    def posInfosToStack(p):
        if (p is None):
            return [haxe_StackItem.FilePos(None,"",0)]
        else:
            return [haxe_StackItem.FilePos(None,p.fileName,p.lineNumber)]

buddy_SuitesRunner._hx_class = buddy_SuitesRunner


class buddy_reporting_Reporter:
    _hx_class_name = "buddy.reporting.Reporter"
    __slots__ = ()
    _hx_methods = ["start", "progress", "done"]
buddy_reporting_Reporter._hx_class = buddy_reporting_Reporter


class buddy_reporting_TraceReporter:
    _hx_class_name = "buddy.reporting.TraceReporter"
    __slots__ = ("colors",)
    _hx_fields = ["colors"]
    _hx_methods = ["start", "progress", "done", "println", "strCol", "resolveImmediately"]
    _hx_interfaces = [buddy_reporting_Reporter]

    def __init__(self,colors = False):
        if (colors is None):
            colors = False
        self.colors = colors

    def start(self):
        return self.resolveImmediately(True)

    def progress(self,spec):
        return self.resolveImmediately(spec)

    def done(self,suites,status):
        _gthis = self
        self.println("")
        total = 0
        failures = 0
        pending = 0
        countTests = None
        printTests = None
        def _hx_local_5(s):
            nonlocal pending
            nonlocal total
            nonlocal failures
            nonlocal failures
            if (s.error is not None):
                failures = (failures + 1)
            _g = 0
            _g1 = s.steps
            while (_g < len(_g1)):
                sp = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                countTests1 = sp.index
                if (countTests1 == 0):
                    s1 = sp.params[0]
                    countTests(s1)
                elif (countTests1 == 1):
                    sp1 = sp.params[0]
                    total = (total + 1)
                    if (sp1.status == buddy_SpecStatus.Failed):
                        failures = (failures + 1)
                    elif (sp1.status == buddy_SpecStatus.Pending):
                        pending = (pending + 1)
                else:
                    pass
        countTests = _hx_local_5
        Lambda.iter(suites,countTests)
        def _hx_local_13(s2,indentLevel):
            success = True
            lines = []
            def _hx_local_6(_hx_str,color = 39):
                if (color is None):
                    color = 39
                start = _gthis.strCol(color)
                end = _gthis.strCol(39)
                str1 = len(_hx_str)
                b = (indentLevel * 2)
                x = (0 if (python_lib_Math.isnan(0)) else (b if (python_lib_Math.isnan(b)) else max(0,b)))
                x1 = None
                try:
                    x1 = int(x)
                except Exception as _hx_e:
                    _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                    e = _hx_e1
                    x1 = None
                x2 = ((("null" if start is None else start) + HxOverrides.stringOrNull(StringTools.lpad(_hx_str," ",(str1 + x1)))) + ("null" if end is None else end))
                lines.append(x2)
            _hx_print = _hx_local_6
            def _hx_local_8(indent,stack):
                if ((stack is None) or ((len(stack) == 0))):
                    return
                _g2 = 0
                while (_g2 < len(stack)):
                    s3 = (stack[_g2] if _g2 >= 0 and _g2 < len(stack) else None)
                    _g2 = (_g2 + 1)
                    if (s3.index == 2):
                        line = s3.params[2]
                        file = s3.params[1]
                        if (((line > 0) and ((file.find("buddy/internal/") != 0))) and ((file.find("buddy.SuitesRunner") != 0))):
                            _hx_print((("null" if indent is None else indent) + HxOverrides.stringOrNull((((("@ " + ("null" if file is None else file)) + ":") + Std.string(line))))),33)
            printStack = _hx_local_8
            def _hx_local_10(spec):
                _g3 = 0
                _g11 = spec.traces
                while (_g3 < len(_g11)):
                    t = (_g11[_g3] if _g3 >= 0 and _g3 < len(_g11) else None)
                    _g3 = (_g3 + 1)
                    _hx_print(("    " + ("null" if t is None else t)),33)
            printTraces = _hx_local_10
            if (len(s2.description) > 0):
                _hx_print(s2.description)
            if (s2.error is not None):
                printTests1 = ("ERROR: " + Std.string(s2.error))
                _hx_print(printTests1,31)
                printStack("  ",s2.stack)
                return _hx_AnonObject({'success': False, 'lines': lines})
            _g4 = 0
            _g12 = s2.steps
            while (_g4 < len(_g12)):
                step = (_g12[_g4] if _g4 >= 0 and _g4 < len(_g12) else None)
                _g4 = (_g4 + 1)
                printTests2 = step.index
                if (printTests2 == 0):
                    s4 = step.params[0]
                    ret = printTests(s4,(indentLevel + 1))
                    success = (success and ret.success)
                    lines = (lines + ret.lines)
                elif (printTests2 == 1):
                    sp2 = step.params[0]
                    success = (success and ((sp2.status == buddy_SpecStatus.Passed)))
                    if (sp2.status == buddy_SpecStatus.Failed):
                        _hx_print((("  " + HxOverrides.stringOrNull(sp2.description)) + " (FAILED)"),31)
                        printTraces(sp2)
                        _g5 = 0
                        _g13 = sp2.failures
                        while (_g5 < len(_g13)):
                            failure = (_g13[_g5] if _g5 >= 0 and _g5 < len(_g13) else None)
                            _g5 = (_g5 + 1)
                            printTests3 = ("    " + Std.string(failure.error))
                            _hx_print(printTests3,33)
                            printStack("      ",failure.stack)
                    else:
                        printTests4 = (((("  " + HxOverrides.stringOrNull(sp2.description)) + " (") + Std.string(sp2.status)) + ")")
                        _hx_print(printTests4,(32 if ((sp2.status == buddy_SpecStatus.Passed)) else 33))
                        printTraces(sp2)
                else:
                    pass
            return _hx_AnonObject({'success': success, 'lines': lines})
        printTests = _hx_local_13
        def _hx_local_14(s5):
            ret1 = printTests(s5,-1)
            Lambda.iter(ret1.lines,_gthis.println)
        Lambda.iter(suites,_hx_local_14)
        totalColor = (31 if ((failures > 0)) else 32)
        pendingColor = (33 if ((pending > 0)) else totalColor)
        self.println(((((HxOverrides.stringOrNull(self.strCol(totalColor)) + HxOverrides.stringOrNull(((((("" + Std.string(total)) + " specs, ") + Std.string(failures)) + " failures, ")))) + HxOverrides.stringOrNull(self.strCol(pendingColor))) + HxOverrides.stringOrNull(((("" + Std.string(pending)) + " pending")))) + HxOverrides.stringOrNull(self.strCol(39))))
        return self.resolveImmediately(suites)

    def println(self,s):
        haxe_Log.trace(s,_hx_AnonObject({'fileName': "buddy/reporting/TraceReporter.hx", 'lineNumber': 159, 'className': "buddy.reporting.TraceReporter", 'methodName': "println"}))

    def strCol(self,color):
        if self.colors:
            return buddy_reporting__TraceReporter_Color_Impl_.ansiCode(color)
        else:
            return ""

    def resolveImmediately(self,o):
        _hx_def = promhx_Deferred()
        pr = _hx_def.promise()
        _hx_def.resolve(o)
        return pr

buddy_reporting_TraceReporter._hx_class = buddy_reporting_TraceReporter


class buddy_reporting_ConsoleReporter(buddy_reporting_TraceReporter):
    _hx_class_name = "buddy.reporting.ConsoleReporter"
    __slots__ = ("progressString",)
    _hx_fields = ["progressString"]
    _hx_methods = ["start", "progress", "done", "print", "println"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = buddy_reporting_TraceReporter


    def __init__(self,colors = False):
        if (colors is None):
            colors = False
        self.progressString = ""
        super().__init__(colors)

    def start(self):
        return self.resolveImmediately(True)

    def progress(self,spec):
        status = None
        status1 = spec.status.index
        if (status1 == 0):
            status = (HxOverrides.stringOrNull(self.strCol(33)) + "?")
        elif (status1 == 1):
            status = (HxOverrides.stringOrNull(self.strCol(32)) + ".")
        elif (status1 == 2):
            status = (HxOverrides.stringOrNull(self.strCol(33)) + "P")
        elif (status1 == 3):
            status = (HxOverrides.stringOrNull(self.strCol(31)) + "X")
        else:
            pass
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.progressString
        _hx_local_0.progressString = (("null" if _hx_local_1 is None else _hx_local_1) + ("null" if status is None else status))
        _hx_local_0.progressString
        self.print((("null" if status is None else status) + HxOverrides.stringOrNull(self.strCol(39))))
        return self.resolveImmediately(spec)

    def done(self,suites,status):
        output = super().done(suites,status)
        return output

    def print(self,s):
        python_Lib.printString(Std.string(s))

    def println(self,s):
        _hx_str = Std.string(s)
        python_Lib.printString((("" + ("null" if _hx_str is None else _hx_str)) + "\n"))

buddy_reporting_ConsoleReporter._hx_class = buddy_reporting_ConsoleReporter


class buddy_reporting__TraceReporter_Color_Impl_:
    _hx_class_name = "buddy.reporting._TraceReporter.Color_Impl_"
    __slots__ = ()
    _hx_statics = ["ansiCode"]

    @staticmethod
    def ansiCode(this1):
        return ("\x1B" + HxOverrides.stringOrNull(((("[" + Std.string(this1)) + "m"))))
buddy_reporting__TraceReporter_Color_Impl_._hx_class = buddy_reporting__TraceReporter_Color_Impl_


class buddy_tests_SelfTest:
    _hx_class_name = "buddy.tests.SelfTest"
    __slots__ = ()
    _hx_statics = ["lastSpec", "lastSuite"]
    lastSpec = None
    lastSuite = None
buddy_tests_SelfTest._hx_class = buddy_tests_SelfTest


class buddy_tools_AsyncTools:
    _hx_class_name = "buddy.tools.AsyncTools"
    __slots__ = ()
    _hx_statics = ["wait"]

    @staticmethod
    def wait(ms):
        _hx_def = promhx_Deferred()
        pr = _hx_def.promise()
        def _hx_local_0():
            if (not pr._fulfilled):
                _hx_def.resolve(True)
        done = _hx_local_0
        buddy_tools_Timer((ms / 1000),done).start()
        return pr
buddy_tools_AsyncTools._hx_class = buddy_tools_AsyncTools

class haxe_StackItem(Enum):
    __slots__ = ()
    _hx_class_name = "haxe.StackItem"
    _hx_constructs = ["CFunction", "Module", "FilePos", "Method", "LocalFunction"]

    @staticmethod
    def Module(m):
        return haxe_StackItem("Module", 1, [m])

    @staticmethod
    def FilePos(s,file,line,column = None):
        return haxe_StackItem("FilePos", 2, [s,file,line,column])

    @staticmethod
    def Method(classname,method):
        return haxe_StackItem("Method", 3, [classname,method])

    @staticmethod
    def LocalFunction(v = None):
        return haxe_StackItem("LocalFunction", 4, [v])
haxe_StackItem.CFunction = haxe_StackItem("CFunction", 0, list())
haxe_StackItem._hx_class = haxe_StackItem


class haxe_CallStack:
    _hx_class_name = "haxe.CallStack"
    __slots__ = ()
    _hx_statics = ["exceptionStack"]

    @staticmethod
    def exceptionStack():
        stack = []
        exc = python_lib_Sys.exc_info()
        if (exc[2] is not None):
            infos = python_lib_Traceback.extract_tb(exc[2])
            infos.reverse()
            _g = 0
            while (_g < len(infos)):
                elem = (infos[_g] if _g >= 0 and _g < len(infos) else None)
                _g = (_g + 1)
                x = haxe_StackItem.FilePos(None,elem[0],elem[1])
                stack.append(x)
        return stack
haxe_CallStack._hx_class = haxe_CallStack


class haxe_EntryPoint:
    _hx_class_name = "haxe.EntryPoint"
    __slots__ = ()
    _hx_statics = ["pending", "threadCount", "processEvents", "run"]

    @staticmethod
    def processEvents():
        while True:
            _this = haxe_EntryPoint.pending
            f = (None if ((len(_this) == 0)) else _this.pop(0))
            if (f is None):
                break
            f()
        time = haxe_MainLoop.tick()
        if ((not haxe_MainLoop.hasEvents()) and ((haxe_EntryPoint.threadCount == 0))):
            return -1
        return time

    @staticmethod
    def run():
        while True:
            nextTick = haxe_EntryPoint.processEvents()
            if (nextTick < 0):
                break
            tmp = (nextTick > 0)
haxe_EntryPoint._hx_class = haxe_EntryPoint


class haxe__Int32_Int32_Impl_:
    _hx_class_name = "haxe._Int32.Int32_Impl_"
    __slots__ = ()
    _hx_statics = ["ucompare"]

    @staticmethod
    def ucompare(a,b):
        if (a < 0):
            if (b < 0):
                return (((((~b + (2 ** 31)) % (2 ** 32) - (2 ** 31)) - (((~a + (2 ** 31)) % (2 ** 32) - (2 ** 31)))) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
            else:
                return 1
        if (b < 0):
            return -1
        else:
            return (((a - b) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
haxe__Int32_Int32_Impl_._hx_class = haxe__Int32_Int32_Impl_


class haxe__Int64____Int64:
    _hx_class_name = "haxe._Int64.___Int64"
    __slots__ = ("high", "low")
    _hx_fields = ["high", "low"]

    def __init__(self,high,low):
        self.high = high
        self.low = low

haxe__Int64____Int64._hx_class = haxe__Int64____Int64


class haxe_Log:
    _hx_class_name = "haxe.Log"
    __slots__ = ()
    _hx_statics = ["formatOutput", "trace"]

    @staticmethod
    def formatOutput(v,infos):
        _hx_str = Std.string(v)
        if (infos is None):
            return _hx_str
        pstr = ((HxOverrides.stringOrNull(infos.fileName) + ":") + Std.string(infos.lineNumber))
        if ((infos is not None) and ((Reflect.field(infos,"customParams") is not None))):
            _g = 0
            _g1 = Reflect.field(infos,"customParams")
            while (_g < len(_g1)):
                v1 = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                _hx_str = (("null" if _hx_str is None else _hx_str) + ((", " + Std.string(v1))))
        return ((("null" if pstr is None else pstr) + ": ") + ("null" if _hx_str is None else _hx_str))

    @staticmethod
    def trace(v,infos = None):
        _hx_str = haxe_Log.formatOutput(v,infos)
        str1 = Std.string(_hx_str)
        python_Lib.printString((("" + ("null" if str1 is None else str1)) + "\n"))
haxe_Log._hx_class = haxe_Log


class haxe_MainEvent:
    _hx_class_name = "haxe.MainEvent"
    __slots__ = ("f", "prev", "next", "isBlocking", "nextRun", "priority")
    _hx_fields = ["f", "prev", "next", "isBlocking", "nextRun", "priority"]

    def __init__(self,f,p):
        self.next = None
        self.prev = None
        self.isBlocking = True
        self.f = f
        self.priority = p
        self.nextRun = -1

haxe_MainEvent._hx_class = haxe_MainEvent


class haxe_MainLoop:
    _hx_class_name = "haxe.MainLoop"
    __slots__ = ()
    _hx_statics = ["pending", "hasEvents", "sortEvents", "tick"]
    pending = None
    threadCount = None

    @staticmethod
    def hasEvents():
        p = haxe_MainLoop.pending
        while (p is not None):
            if p.isBlocking:
                return True
            p = p.next
        return False

    @staticmethod
    def sortEvents():
        _hx_list = haxe_MainLoop.pending
        if (_hx_list is None):
            return
        insize = 1
        nmerges = None
        psize = 0
        qsize = 0
        p = None
        q = None
        e = None
        tail = None
        while True:
            p = _hx_list
            _hx_list = None
            tail = None
            nmerges = 0
            while (p is not None):
                nmerges = (nmerges + 1)
                q = p
                psize = 0
                _g = 0
                _g1 = insize
                while (_g < _g1):
                    i = _g
                    _g = (_g + 1)
                    psize = (psize + 1)
                    q = q.next
                    if (q is None):
                        break
                qsize = insize
                while ((psize > 0) or (((qsize > 0) and ((q is not None))))):
                    if (psize == 0):
                        e = q
                        q = q.next
                        qsize = (qsize - 1)
                    elif (((qsize == 0) or ((q is None))) or (((p.priority > q.priority) or (((p.priority == q.priority) and ((p.nextRun <= q.nextRun))))))):
                        e = p
                        p = p.next
                        psize = (psize - 1)
                    else:
                        e = q
                        q = q.next
                        qsize = (qsize - 1)
                    if (tail is not None):
                        tail.next = e
                    else:
                        _hx_list = e
                    e.prev = tail
                    tail = e
                p = q
            tail.next = None
            if (nmerges <= 1):
                break
            insize = (insize * 2)
        _hx_list.prev = None
        haxe_MainLoop.pending = _hx_list

    @staticmethod
    def tick():
        haxe_MainLoop.sortEvents()
        e = haxe_MainLoop.pending
        now = python_lib_Timeit.default_timer()
        wait = 1e9
        while (e is not None):
            next = e.next
            wt = (e.nextRun - now)
            if ((e.nextRun < 0) or ((wt <= 0))):
                wait = 0
                if (e.f is not None):
                    e.f()
            elif (wait > wt):
                wait = wt
            e = next
        return wait
haxe_MainLoop._hx_class = haxe_MainLoop


class haxe_ds_GenericCell:
    _hx_class_name = "haxe.ds.GenericCell"
    __slots__ = ("elt", "next")
    _hx_fields = ["elt", "next"]

    def __init__(self,elt,next):
        self.elt = elt
        self.next = next

haxe_ds_GenericCell._hx_class = haxe_ds_GenericCell


class haxe_ds_GenericStack:
    _hx_class_name = "haxe.ds.GenericStack"
    __slots__ = ("head",)
    _hx_fields = ["head"]

    def __init__(self):
        self.head = None

haxe_ds_GenericStack._hx_class = haxe_ds_GenericStack


class haxe_ds_IntMap:
    _hx_class_name = "haxe.ds.IntMap"
    __slots__ = ("h",)
    _hx_fields = ["h"]
    _hx_methods = ["set", "keys", "toString"]
    _hx_interfaces = [haxe_IMap]

    def __init__(self):
        self.h = dict()

    def set(self,key,value):
        self.h[key] = value

    def keys(self):
        return python_HaxeIterator(iter(self.h.keys()))

    def toString(self):
        s_b = python_lib_io_StringIO()
        s_b.write("{")
        it = self.keys()
        i = it
        while i.hasNext():
            i1 = i.next()
            s_b.write(Std.string(i1))
            s_b.write(" => ")
            s_b.write(Std.string(Std.string(self.h.get(i1,None))))
            if it.hasNext():
                s_b.write(", ")
        s_b.write("}")
        return s_b.getvalue()

haxe_ds_IntMap._hx_class = haxe_ds_IntMap


class haxe_ds_List:
    _hx_class_name = "haxe.ds.List"
    __slots__ = ("h", "q", "length")
    _hx_fields = ["h", "q", "length"]
    _hx_methods = ["add", "pop", "isEmpty", "iterator", "filter"]

    def __init__(self):
        self.q = None
        self.h = None
        self.length = 0

    def add(self,item):
        x = haxe_ds__List_ListNode(item,None)
        if (self.h is None):
            self.h = x
        else:
            self.q.next = x
        self.q = x
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.length
        _hx_local_0.length = (_hx_local_1 + 1)
        _hx_local_1

    def pop(self):
        if (self.h is None):
            return None
        x = self.h.item
        self.h = self.h.next
        if (self.h is None):
            self.q = None
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.length
        _hx_local_0.length = (_hx_local_1 - 1)
        _hx_local_1
        return x

    def isEmpty(self):
        return (self.h is None)

    def iterator(self):
        return haxe_ds__List_ListIterator(self.h)

    def filter(self,f):
        l2 = haxe_ds_List()
        l = self.h
        while (l is not None):
            v = l.item
            l = l.next
            if f(v):
                l2.add(v)
        return l2

haxe_ds_List._hx_class = haxe_ds_List


class haxe_ds__List_ListNode:
    _hx_class_name = "haxe.ds._List.ListNode"
    __slots__ = ("item", "next")
    _hx_fields = ["item", "next"]

    def __init__(self,item,next):
        self.item = item
        self.next = next

haxe_ds__List_ListNode._hx_class = haxe_ds__List_ListNode


class haxe_ds__List_ListIterator:
    _hx_class_name = "haxe.ds._List.ListIterator"
    __slots__ = ("head",)
    _hx_fields = ["head"]
    _hx_methods = ["hasNext", "next"]

    def __init__(self,head):
        self.head = head

    def hasNext(self):
        return (self.head is not None)

    def next(self):
        val = self.head.item
        self.head = self.head.next
        return val

haxe_ds__List_ListIterator._hx_class = haxe_ds__List_ListIterator

class haxe_ds_Option(Enum):
    __slots__ = ()
    _hx_class_name = "haxe.ds.Option"
    _hx_constructs = ["Some", "None"]

    @staticmethod
    def Some(v):
        return haxe_ds_Option("Some", 0, [v])
haxe_ds_Option._hx_None = haxe_ds_Option("None", 1, list())
haxe_ds_Option._hx_class = haxe_ds_Option


class haxe_rtti_Meta:
    _hx_class_name = "haxe.rtti.Meta"
    __slots__ = ()
    _hx_statics = ["getType", "getMeta"]

    @staticmethod
    def getType(t):
        meta = haxe_rtti_Meta.getMeta(t)
        if ((meta is None) or ((Reflect.field(meta,"obj") is None))):
            return _hx_AnonObject({})
        else:
            return Reflect.field(meta,"obj")

    @staticmethod
    def getMeta(t):
        return Reflect.field(t,"__meta__")
haxe_rtti_Meta._hx_class = haxe_rtti_Meta


class logipar_Logipar:
    _hx_class_name = "logipar.Logipar"
    __slots__ = ("quotations", "caseSensitive", "syntax", "tree")
    _hx_fields = ["quotations", "caseSensitive", "syntax", "tree"]
    _hx_methods = ["overwrite", "parse", "stringify", "filterFunction", "toString", "treeify", "shunt", "tentativelyLower", "tokenize", "tokenType", "typeize"]

    def __init__(self):
        self.tree = None
        _g = haxe_ds_StringMap()
        _g.h["AND"] = "AND"
        _g.h["OR"] = "OR"
        _g.h["XOR"] = "XOR"
        _g.h["NOT"] = "NOT"
        _g.h["OPEN"] = "("
        _g.h["CLOSE"] = ")"
        self.syntax = _g
        self.caseSensitive = True
        self.quotations = ["\"", "'"]

    def overwrite(self,op,value):
        if (op in self.syntax.h):
            self.syntax.h[op] = value

    def parse(self,logic_string):
        tokens = self.tokenize(logic_string)
        types = self.typeize(tokens)
        reversepolish = self.shunt(types)
        self.tree = self.treeify(reversepolish)
        return self.tree

    def stringify(self,f = None):
        if (self.tree is None):
            return None
        else:
            return self.tree.fancyString(f)

    def filterFunction(self,f):
        enclosed = self.tree
        def _hx_local_0(a):
            if (enclosed is None):
                return True
            return enclosed.check(a,f)
        return _hx_local_0

    def toString(self):
        return self.stringify()

    def treeify(self,tokens):
        stack = haxe_ds_GenericStack()
        _g = 0
        _g1 = len(tokens)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            token = (tokens[i] if i >= 0 and i < len(tokens) else None)
            n = logipar_Node(token)
            if (token.type != "LITERAL"):
                if (stack.head is None):
                    raise _HxException((("An '" + HxOverrides.stringOrNull(self.syntax.h.get(token.type,None))) + "' is missing a value to operate on (on its right)."))
                k = stack.head
                tmp = None
                if (k is None):
                    tmp = None
                else:
                    stack.head = k.next
                    tmp = k.elt
                n.right = tmp
                if (token.type != "NOT"):
                    if (stack.head is None):
                        raise _HxException((("An '" + HxOverrides.stringOrNull(self.syntax.h.get(token.type,None))) + "' is missing a value to operate on (on its left)."))
                    k1 = stack.head
                    tmp1 = None
                    if (k1 is None):
                        tmp1 = None
                    else:
                        stack.head = k1.next
                        tmp1 = k1.elt
                    n.left = tmp1
            stack.head = haxe_ds_GenericCell(n,stack.head)
        k2 = stack.head
        parsetree = None
        if (k2 is None):
            parsetree = None
        else:
            stack.head = k2.next
            parsetree = k2.elt
        parsetree1 = parsetree
        if (stack.head is not None):
            raise _HxException("Uhoh, the stack isn't empty.  Do you have neighbouring literals?")
        return parsetree1

    def shunt(self,tokens):
        output = list()
        operators = haxe_ds_GenericStack()
        _g = 0
        _g1 = len(tokens)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            token = (tokens[i] if i >= 0 and i < len(tokens) else None)
            _g2 = token.type
            _hx_local_0 = len(_g2)
            if (_hx_local_0 == 5):
                if (_g2 == "CLOSE"):
                    while True:
                        k = operators.head
                        op = None
                        if (k is None):
                            op = None
                        else:
                            operators.head = k.next
                            op = k.elt
                        op1 = op
                        if (op1.type == "OPEN"):
                            break
                        if (operators.head is None):
                            raise _HxException("Mismatched parentheses.")
                        output.append(op1)
                else:
                    while (operators.head is not None):
                        prev = (None if ((operators.head is None)) else operators.head.elt)
                        if (prev.type == "OPEN"):
                            break
                        if (prev.precedence() <= token.precedence()):
                            break
                        k1 = operators.head
                        x = None
                        if (k1 is None):
                            x = None
                        else:
                            operators.head = k1.next
                            x = k1.elt
                        output.append(x)
                    operators.head = haxe_ds_GenericCell(token,operators.head)
            elif (_hx_local_0 == 4):
                if (_g2 == "OPEN"):
                    operators.head = haxe_ds_GenericCell(token,operators.head)
                else:
                    while (operators.head is not None):
                        prev = (None if ((operators.head is None)) else operators.head.elt)
                        if (prev.type == "OPEN"):
                            break
                        if (prev.precedence() <= token.precedence()):
                            break
                        k1 = operators.head
                        x = None
                        if (k1 is None):
                            x = None
                        else:
                            operators.head = k1.next
                            x = k1.elt
                        output.append(x)
                    operators.head = haxe_ds_GenericCell(token,operators.head)
            elif (_hx_local_0 == 7):
                if (_g2 == "LITERAL"):
                    output.append(token)
                else:
                    while (operators.head is not None):
                        prev = (None if ((operators.head is None)) else operators.head.elt)
                        if (prev.type == "OPEN"):
                            break
                        if (prev.precedence() <= token.precedence()):
                            break
                        k1 = operators.head
                        x = None
                        if (k1 is None):
                            x = None
                        else:
                            operators.head = k1.next
                            x = k1.elt
                        output.append(x)
                    operators.head = haxe_ds_GenericCell(token,operators.head)
            else:
                while (operators.head is not None):
                    prev = (None if ((operators.head is None)) else operators.head.elt)
                    if (prev.type == "OPEN"):
                        break
                    if (prev.precedence() <= token.precedence()):
                        break
                    k1 = operators.head
                    x = None
                    if (k1 is None):
                        x = None
                    else:
                        operators.head = k1.next
                        x = k1.elt
                    output.append(x)
                operators.head = haxe_ds_GenericCell(token,operators.head)
        while (operators.head is not None):
            k2 = operators.head
            o = None
            if (k2 is None):
                o = None
            else:
                operators.head = k2.next
                o = k2.elt
            o1 = o
            if (o1.type == "OPEN"):
                raise _HxException("Mismatched parentheses.")
            output.append(o1)
        return output

    def tentativelyLower(self,s):
        if self.caseSensitive:
            return s
        else:
            return Std.string(s).lower()

    def tokenize(self,_hx_str):
        tokens = []
        _g = []
        x = self.syntax.iterator()
        while x.hasNext():
            x1 = x.next()
            x2 = self.tentativelyLower(x1)
            _g.append(x2)
        keys = _g
        quotation = None
        current = ""
        _g1 = 0
        _g2 = len(_hx_str)
        while (_g1 < _g2):
            i = _g1
            _g1 = (_g1 + 1)
            c = ("" if (((i < 0) or ((i >= len(_hx_str))))) else _hx_str[i])
            if (python_internal_ArrayImpl.indexOf(keys,self.tentativelyLower(c),None) == -1):
                if (python_internal_ArrayImpl.indexOf(self.quotations,c,None) != -1):
                    if (quotation is None):
                        quotation = c
                    elif (quotation == c):
                        quotation = None
                if (StringTools.isSpace(c,0) and ((quotation is None))):
                    if (len(current) > 0):
                        tokens.append(current)
                    current = ""
                else:
                    current = (("null" if current is None else current) + ("null" if c is None else c))
            else:
                if (len(current) > 0):
                    tokens.append(current)
                current = ""
                tokens.append(c)
        if (len(StringTools.trim(current)) > 0):
            x3 = StringTools.trim(current)
            tokens.append(x3)
        return tokens

    def tokenType(self,token):
        key = self.syntax.keys()
        while key.hasNext():
            key1 = key.next()
            if (self.tentativelyLower(token) == self.tentativelyLower(self.syntax.h.get(key1,None))):
                return logipar_Token(key1)
        return logipar_Token("LITERAL",token)

    def typeize(self,tokens):
        _g = []
        _g1 = 0
        _g2 = len(tokens)
        while (_g1 < _g2):
            i = _g1
            _g1 = (_g1 + 1)
            x = self.tokenType((tokens[i] if i >= 0 and i < len(tokens) else None))
            _g.append(x)
        return _g

logipar_Logipar._hx_class = logipar_Logipar


class logipar_Node:
    _hx_class_name = "logipar.Node"
    __slots__ = ("token", "left", "right", "f")
    _hx_fields = ["token", "left", "right", "f"]
    _hx_methods = ["toString", "fancyString", "_fancyString", "check"]

    def __init__(self,token):
        self.f = None
        self.right = None
        self.left = None
        self.token = token

    def toString(self):
        return self.fancyString()

    def fancyString(self,f = None):
        return self._fancyString(self,f)

    def _fancyString(self,n,f = None):
        s = None
        if (f is not None):
            f1 = self._fancyString
            f2 = f
            def _hx_local_0(n1):
                return f1(n1,f2)
            n.f = _hx_local_0
            s = f(n)
            n.f = None
        if (s is not None):
            return s
        _g = n.token.type
        _hx_local_1 = len(_g)
        if (_hx_local_1 == 7):
            if (_g == "LITERAL"):
                return (("{" + HxOverrides.stringOrNull(n.token.literal)) + "}")
            else:
                return (((((("(" + HxOverrides.stringOrNull(n.left.fancyString(f))) + " ") + Std.string(n.token.type)) + " ") + HxOverrides.stringOrNull(n.right.fancyString(f))) + ")")
        elif (_hx_local_1 == 3):
            if (_g == "NOT"):
                return (("NOT(" + HxOverrides.stringOrNull(n.right.fancyString(f))) + ")")
            else:
                return (((((("(" + HxOverrides.stringOrNull(n.left.fancyString(f))) + " ") + Std.string(n.token.type)) + " ") + HxOverrides.stringOrNull(n.right.fancyString(f))) + ")")
        else:
            return (((((("(" + HxOverrides.stringOrNull(n.left.fancyString(f))) + " ") + Std.string(n.token.type)) + " ") + HxOverrides.stringOrNull(n.right.fancyString(f))) + ")")

    def check(self,a,f):
        _g = self.token.type
        _hx_local_0 = len(_g)
        if (_hx_local_0 == 3):
            if (_g == "AND"):
                if self.left.check(a,f):
                    return self.right.check(a,f)
                else:
                    return False
            elif (_g == "NOT"):
                return (not self.right.check(a,f))
            elif (_g == "XOR"):
                l = self.left.check(a,f)
                r = self.right.check(a,f)
                if (not (((not l) and r))):
                    if l:
                        return (not r)
                    else:
                        return False
                else:
                    return True
            else:
                raise _HxException("Unexpected token encountered.")
        elif (_hx_local_0 == 7):
            if (_g == "LITERAL"):
                return f(a,self.token.literal)
            else:
                raise _HxException("Unexpected token encountered.")
        elif (_hx_local_0 == 2):
            if (_g == "OR"):
                if (not self.left.check(a,f)):
                    return self.right.check(a,f)
                else:
                    return True
            else:
                raise _HxException("Unexpected token encountered.")
        else:
            raise _HxException("Unexpected token encountered.")

logipar_Node._hx_class = logipar_Node


class logipar_Token:
    _hx_class_name = "logipar.Token"
    __slots__ = ("type", "literal")
    _hx_fields = ["type", "literal"]
    _hx_methods = ["precedence", "toString"]
    _hx_statics = ["AND", "OR", "XOR", "NOT", "OPEN", "CLOSE", "LITERAL"]

    def __init__(self,_hx_type,literal = None):
        self.type = _hx_type
        self.literal = literal

    def precedence(self):
        _g = self.type
        _hx_local_0 = len(_g)
        if (_hx_local_0 == 3):
            if (_g == "AND"):
                return 2
            elif (_g == "NOT"):
                return 2
            elif (_g == "XOR"):
                return 1
            else:
                return 0
        elif (_hx_local_0 == 2):
            if (_g == "OR"):
                return 1
            else:
                return 0
        else:
            return 0

    def toString(self):
        if (self.type == "LITERAL"):
            return (("LITERAL(" + HxOverrides.stringOrNull(self.literal)) + ")")
        return Std.string(self.type)

logipar_Token._hx_class = logipar_Token


class promhx_base_AsyncBase:
    _hx_class_name = "promhx.base.AsyncBase"
    __slots__ = ("_val", "_resolved", "_fulfilled", "_pending", "_update", "_error", "_errored", "_errorMap", "_errorVal", "_errorPending")
    _hx_fields = ["_val", "_resolved", "_fulfilled", "_pending", "_update", "_error", "_errored", "_errorMap", "_errorVal", "_errorPending"]
    _hx_methods = ["catchError", "handleResolve", "_resolve", "handleError", "_handleError"]
    _hx_statics = ["immediateLinkUpdate", "allFulfilled"]

    def __init__(self,d = None):
        self._errorVal = None
        self._errorMap = None
        self._val = None
        self._resolved = False
        self._pending = False
        self._errorPending = False
        self._fulfilled = False
        self._update = []
        self._error = []
        self._errored = False
        if (d is not None):
            next = self
            def _hx_local_0(x):
                return x
            f = _hx_local_0
            _this = d._update
            def _hx_local_1(x1):
                tmp = f(x1)
                next.handleResolve(tmp)
            _this.append(_hx_AnonObject({'_hx_async': next, 'linkf': _hx_local_1}))
            promhx_base_AsyncBase.immediateLinkUpdate(d,next,f)

    def catchError(self,f):
        _this = self._error
        _this.append(f)
        return self

    def handleResolve(self,val):
        self._resolve(val)

    def _resolve(self,val):
        _gthis = self
        if self._pending:
            f = self._resolve
            val1 = val
            def _hx_local_0():
                f(val1)
            tmp = _hx_local_0
            promhx_base_EventLoop.queue.add(tmp)
            promhx_base_EventLoop.continueOnNextLoop()
        else:
            self._resolved = True
            self._pending = True
            def _hx_local_2():
                _gthis._val = val
                _g = 0
                _g1 = _gthis._update
                while (_g < len(_g1)):
                    up = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                    _g = (_g + 1)
                    try:
                        up.linkf(val)
                    except Exception as _hx_e:
                        _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                        e = _hx_e1
                        up._hx_async.handleError(e)
                _gthis._fulfilled = True
                _gthis._pending = False
            promhx_base_EventLoop.queue.add(_hx_local_2)
            promhx_base_EventLoop.continueOnNextLoop()

    def handleError(self,error):
        self._handleError(error)

    def _handleError(self,error):
        _gthis = self
        def _hx_local_2(e):
            if (len(_gthis._error) > 0):
                _g = 0
                _g1 = _gthis._error
                while (_g < len(_g1)):
                    ef = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                    _g = (_g + 1)
                    ef(e)
            elif (len(_gthis._update) > 0):
                _g2 = 0
                _g11 = _gthis._update
                while (_g2 < len(_g11)):
                    up = (_g11[_g2] if _g2 >= 0 and _g2 < len(_g11) else None)
                    _g2 = (_g2 + 1)
                    up._hx_async.handleError(e)
            else:
                raise _HxException(e)
            _gthis._errorPending = False
        update_errors = _hx_local_2
        if (not self._errorPending):
            self._errorPending = True
            self._errored = True
            self._errorVal = error
            def _hx_local_3():
                if (_gthis._errorMap is not None):
                    try:
                        tmp = _gthis._errorMap(error)
                        _gthis._resolve(tmp)
                    except Exception as _hx_e:
                        _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                        e1 = _hx_e1
                        update_errors(e1)
                else:
                    update_errors(error)
            promhx_base_EventLoop.queue.add(_hx_local_3)
            promhx_base_EventLoop.continueOnNextLoop()

    @staticmethod
    def immediateLinkUpdate(current,next,f):
        if ((current._errored and (not current._errorPending)) and ((len(current._error) <= 0))):
            next.handleError(current._errorVal)
        if (current._resolved and (not current._pending)):
            try:
                next.handleResolve(f(current._val))
            except Exception as _hx_e:
                _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                e = _hx_e1
                next.handleError(e)

    @staticmethod
    def allFulfilled(_hx_as):
        a = HxOverrides.iterator(_hx_as)
        while a.hasNext():
            a1 = a.next()
            if (not a1._fulfilled):
                return False
        return True

promhx_base_AsyncBase._hx_class = promhx_base_AsyncBase


class promhx_Deferred(promhx_base_AsyncBase):
    _hx_class_name = "promhx.Deferred"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["resolve", "throwError", "promise", "stream", "publicStream"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = promhx_base_AsyncBase


    def __init__(self):
        super().__init__()

    def resolve(self,val):
        self.handleResolve(val)

    def throwError(self,e):
        self.handleError(e)

    def promise(self):
        return promhx_Promise(self)

    def stream(self):
        return promhx_Stream(self)

    def publicStream(self):
        return promhx_PublicStream(self)

promhx_Deferred._hx_class = promhx_Deferred


class promhx_Promise(promhx_base_AsyncBase):
    _hx_class_name = "promhx.Promise"
    __slots__ = ("_rejected",)
    _hx_fields = ["_rejected"]
    _hx_methods = ["isRejected", "reject", "handleResolve", "then", "unlink", "handleError", "pipe", "errorPipe"]
    _hx_statics = ["whenAll", "promise"]
    _hx_interfaces = []
    _hx_super = promhx_base_AsyncBase


    def __init__(self,d = None):
        self._rejected = None
        super().__init__(d)
        self._rejected = False

    def isRejected(self):
        return self._rejected

    def reject(self,e):
        self._rejected = True
        self.handleError(e)

    def handleResolve(self,val):
        if self._resolved:
            msg = "Promise has already been resolved"
            raise _HxException(promhx_error_PromiseError.AlreadyResolved(msg))
        self._resolve(val)

    def then(self,f):
        ret = promhx_Promise(None)
        next = ret
        f1 = f
        _this = self._update
        def _hx_local_0(x):
            tmp = f1(x)
            next.handleResolve(tmp)
        _this.append(_hx_AnonObject({'_hx_async': next, 'linkf': _hx_local_0}))
        promhx_base_AsyncBase.immediateLinkUpdate(self,next,f1)
        return ret

    def unlink(self,to):
        _gthis = self
        def _hx_local_1():
            if (not _gthis._fulfilled):
                msg = "Downstream Promise is not fullfilled"
                _gthis.handleError(promhx_error_PromiseError.DownstreamNotFullfilled(msg))
            else:
                def _hx_local_0(x):
                    return (x._hx_async != to)
                tmp = list(filter(_hx_local_0,_gthis._update))
                _gthis._update = tmp
        promhx_base_EventLoop.queue.add(_hx_local_1)
        promhx_base_EventLoop.continueOnNextLoop()

    def handleError(self,error):
        self._rejected = True
        self._handleError(error)

    def pipe(self,f):
        ret = promhx_Promise(None)
        ret1 = ret
        f1 = f
        linked = False
        def _hx_local_1(x):
            nonlocal linked
            if (not linked):
                linked = True
                pipe_ret = f1(x)
                _this = pipe_ret._update
                _this.append(_hx_AnonObject({'_hx_async': ret1, 'linkf': ret1.handleResolve}))
                def _hx_local_0(x1):
                    return x1
                promhx_base_AsyncBase.immediateLinkUpdate(pipe_ret,ret1,_hx_local_0)
        linkf = _hx_local_1
        _this1 = self._update
        _this1.append(_hx_AnonObject({'_hx_async': ret1, 'linkf': linkf}))
        if (self._resolved and (not self._pending)):
            try:
                linkf(self._val)
            except Exception as _hx_e:
                _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                e = _hx_e1
                ret1.handleError(e)
        return ret

    def errorPipe(self,f):
        ret = promhx_Promise()
        def _hx_local_0(e):
            piped = f(e)
            piped.then(ret._resolve)
        self.catchError(_hx_local_0)
        self.then(ret._resolve)
        return ret

    @staticmethod
    def whenAll(itb):
        ret = promhx_Promise(None)
        all = itb
        next = ret
        def _hx_local_0(arr,current,v):
            if ((len(arr) == 0) or promhx_base_AsyncBase.allFulfilled(arr)):
                _g = []
                a = HxOverrides.iterator(all)
                while a.hasNext():
                    a1 = a.next()
                    x = (v if ((a1 == current)) else a1._val)
                    _g.append(x)
                vals = _g
                next.handleResolve(vals)
            return
        cthen = _hx_local_0
        a2 = HxOverrides.iterator(all)
        while a2.hasNext():
            a3 = a2.next()
            _this = a3._update
            f = [cthen]
            _g1 = []
            a21 = HxOverrides.iterator(all)
            while a21.hasNext():
                a22 = a21.next()
                if (a22 != a3):
                    _g1.append(a22)
            def _hx_local_2(current1,arr1,f1):
                def _hx_local_1(v1):
                    (f1[0] if 0 < len(f1) else None)((arr1[0] if 0 < len(arr1) else None),(current1[0] if 0 < len(current1) else None),v1)
                    return
                return _hx_local_1
            x1 = _hx_local_2([a3],[_g1],f)
            x2 = _hx_AnonObject({'_hx_async': next, 'linkf': x1})
            _this.append(x2)
        if promhx_base_AsyncBase.allFulfilled(all):
            _g2 = []
            a4 = HxOverrides.iterator(all)
            while a4.hasNext():
                a5 = a4.next()
                x3 = a5._val
                _g2.append(x3)
            next.handleResolve(_g2)
        return ret

    @staticmethod
    def promise(_val):
        ret = promhx_Promise()
        ret.handleResolve(_val)
        return ret

promhx_Promise._hx_class = promhx_Promise


class promhx_Stream(promhx_base_AsyncBase):
    _hx_class_name = "promhx.Stream"
    __slots__ = ("deferred", "_pause", "_end", "_end_promise")
    _hx_fields = ["deferred", "_pause", "_end", "_end_promise"]
    _hx_methods = ["then", "detachStream", "first", "handleResolve", "pause", "pipe", "errorPipe", "handleEnd", "end", "endThen", "filter", "concat", "merge"]
    _hx_statics = ["foreach", "wheneverAll", "concatAll", "mergeAll", "stream"]
    _hx_interfaces = []
    _hx_super = promhx_base_AsyncBase


    def __init__(self,d = None):
        self._end_promise = None
        self._end = None
        self._pause = None
        self.deferred = None
        super().__init__(d)
        self._end_promise = promhx_Promise()

    def then(self,f):
        ret = promhx_Stream(None)
        next = ret
        f1 = f
        _this = self._update
        def _hx_local_0(x):
            tmp = f1(x)
            next.handleResolve(tmp)
        _this.append(_hx_AnonObject({'_hx_async': next, 'linkf': _hx_local_0}))
        promhx_base_AsyncBase.immediateLinkUpdate(self,next,f1)
        _this1 = self._end_promise._update
        def _hx_local_1(x2):
            ret.end()
        x1 = _hx_AnonObject({'_hx_async': ret._end_promise, 'linkf': _hx_local_1})
        _this1.append(x1)
        return ret

    def detachStream(self,_hx_str):
        filtered = []
        removed = False
        _g = 0
        _g1 = self._update
        while (_g < len(_g1)):
            u = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if (u._hx_async == _hx_str):
                def _hx_local_1(x):
                    return (x._hx_async != _hx_str._end_promise)
                tmp = list(filter(_hx_local_1,self._end_promise._update))
                self._end_promise._update = tmp
                removed = True
            else:
                filtered.append(u)
        self._update = filtered
        return removed

    def first(self):
        s = promhx_Promise(None)
        def _hx_local_0(x):
            if (not s._resolved):
                s.handleResolve(x)
        self.then(_hx_local_0)
        return s

    def handleResolve(self,val):
        if ((not self._end) and (not self._pause)):
            self._resolve(val)

    def pause(self,_hx_set = None):
        if (_hx_set is None):
            _hx_set = (not self._pause)
        self._pause = _hx_set

    def pipe(self,f):
        ret = promhx_Stream(None)
        ret1 = ret
        f1 = f
        linked = False
        def _hx_local_1(x):
            nonlocal linked
            if (not linked):
                linked = True
                pipe_ret = f1(x)
                _this = pipe_ret._update
                _this.append(_hx_AnonObject({'_hx_async': ret1, 'linkf': ret1.handleResolve}))
                def _hx_local_0(x1):
                    return x1
                promhx_base_AsyncBase.immediateLinkUpdate(pipe_ret,ret1,_hx_local_0)
        linkf = _hx_local_1
        _this1 = self._update
        _this1.append(_hx_AnonObject({'_hx_async': ret1, 'linkf': linkf}))
        if (self._resolved and (not self._pending)):
            try:
                linkf(self._val)
            except Exception as _hx_e:
                _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                e = _hx_e1
                ret1.handleError(e)
        def _hx_local_2(x2):
            ret.end()
        self._end_promise.then(_hx_local_2)
        return ret

    def errorPipe(self,f):
        ret = promhx_Stream(None)
        def _hx_local_0(e):
            piped = f(e)
            piped.then(ret._resolve)
            piped._end_promise.then(ret._end_promise._resolve)
        self.catchError(_hx_local_0)
        self.then(ret._resolve)
        def _hx_local_1(x):
            ret.end()
        self._end_promise.then(_hx_local_1)
        return ret

    def handleEnd(self):
        if self._pending:
            promhx_base_EventLoop.queue.add(self.handleEnd)
            promhx_base_EventLoop.continueOnNextLoop()
        elif self._end_promise._resolved:
            return
        else:
            self._end = True
            o = (haxe_ds_Option.Some(self._val) if (self._resolved) else haxe_ds_Option._hx_None)
            self._end_promise.handleResolve(o)
            self._update = []
            self._error = []

    def end(self):
        promhx_base_EventLoop.queue.add(self.handleEnd)
        promhx_base_EventLoop.continueOnNextLoop()
        return self

    def endThen(self,f):
        return self._end_promise.then(f)

    def filter(self,f):
        ret = promhx_Stream(None)
        _this = self._update
        def _hx_local_0(x):
            if f(x):
                ret.handleResolve(x)
        _this.append(_hx_AnonObject({'_hx_async': ret, 'linkf': _hx_local_0}))
        def _hx_local_1(x1):
            return x1
        promhx_base_AsyncBase.immediateLinkUpdate(self,ret,_hx_local_1)
        return ret

    def concat(self,s):
        ret = promhx_Stream(None)
        _this = self._update
        _this.append(_hx_AnonObject({'_hx_async': ret, 'linkf': ret.handleResolve}))
        def _hx_local_0(x):
            return x
        promhx_base_AsyncBase.immediateLinkUpdate(self,ret,_hx_local_0)
        def _hx_local_3(_):
            def _hx_local_1(x1):
                ret.handleResolve(x1)
                return ret
            s.pipe(_hx_local_1)
            def _hx_local_2(_1):
                ret.end()
            s._end_promise.then(_hx_local_2)
        self._end_promise.then(_hx_local_3)
        return ret

    def merge(self,s):
        ret = promhx_Stream(None)
        _this = self._update
        _this.append(_hx_AnonObject({'_hx_async': ret, 'linkf': ret.handleResolve}))
        _this1 = s._update
        _this1.append(_hx_AnonObject({'_hx_async': ret, 'linkf': ret.handleResolve}))
        def _hx_local_0(x):
            return x
        promhx_base_AsyncBase.immediateLinkUpdate(self,ret,_hx_local_0)
        def _hx_local_1(x1):
            return x1
        promhx_base_AsyncBase.immediateLinkUpdate(s,ret,_hx_local_1)
        return ret

    @staticmethod
    def foreach(itb):
        s = promhx_Stream(None)
        i = HxOverrides.iterator(itb)
        while i.hasNext():
            i1 = i.next()
            s.handleResolve(i1)
        s.end()
        return s

    @staticmethod
    def wheneverAll(itb):
        ret = promhx_Stream(None)
        all = itb
        next = ret
        def _hx_local_0(arr,current,v):
            if ((len(arr) == 0) or promhx_base_AsyncBase.allFulfilled(arr)):
                _g = []
                a = HxOverrides.iterator(all)
                while a.hasNext():
                    a1 = a.next()
                    x = (v if ((a1 == current)) else a1._val)
                    _g.append(x)
                vals = _g
                next.handleResolve(vals)
            return
        cthen = _hx_local_0
        a2 = HxOverrides.iterator(all)
        while a2.hasNext():
            a3 = a2.next()
            _this = a3._update
            f = [cthen]
            _g1 = []
            a21 = HxOverrides.iterator(all)
            while a21.hasNext():
                a22 = a21.next()
                if (a22 != a3):
                    _g1.append(a22)
            def _hx_local_2(current1,arr1,f1):
                def _hx_local_1(v1):
                    (f1[0] if 0 < len(f1) else None)((arr1[0] if 0 < len(arr1) else None),(current1[0] if 0 < len(current1) else None),v1)
                    return
                return _hx_local_1
            x1 = _hx_local_2([a3],[_g1],f)
            x2 = _hx_AnonObject({'_hx_async': next, 'linkf': x1})
            _this.append(x2)
        if promhx_base_AsyncBase.allFulfilled(all):
            _g2 = []
            a4 = HxOverrides.iterator(all)
            while a4.hasNext():
                a5 = a4.next()
                x3 = a5._val
                _g2.append(x3)
            next.handleResolve(_g2)
        return ret

    @staticmethod
    def concatAll(itb):
        ret = promhx_Stream(None)
        i = HxOverrides.iterator(itb)
        while i.hasNext():
            i1 = i.next()
            ret.concat(i1)
        return ret

    @staticmethod
    def mergeAll(itb):
        ret = promhx_Stream(None)
        i = HxOverrides.iterator(itb)
        while i.hasNext():
            i1 = i.next()
            ret.merge(i1)
        return ret

    @staticmethod
    def stream(_val):
        ret = promhx_Stream(None)
        ret.handleResolve(_val)
        return ret

promhx_Stream._hx_class = promhx_Stream


class promhx_PublicStream(promhx_Stream):
    _hx_class_name = "promhx.PublicStream"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["resolve", "throwError", "update"]
    _hx_statics = ["publicstream"]
    _hx_interfaces = []
    _hx_super = promhx_Stream


    def __init__(self,_hx_def = None):
        super().__init__(_hx_def)

    def resolve(self,val):
        self.handleResolve(val)

    def throwError(self,e):
        self.handleError(e)

    def update(self,val):
        self.handleResolve(val)

    @staticmethod
    def publicstream(val):
        ps = promhx_PublicStream(None)
        ps.handleResolve(val)
        return ps

promhx_PublicStream._hx_class = promhx_PublicStream


class promhx_base_EventLoop:
    _hx_class_name = "promhx.base.EventLoop"
    __slots__ = ()
    _hx_statics = ["queue", "nextLoop", "f", "continueOnNextLoop"]
    nextLoop = None

    @staticmethod
    def f():
        fn = promhx_base_EventLoop.queue.pop()
        if (fn is not None):
            fn()
        if (not promhx_base_EventLoop.queue.isEmpty()):
            promhx_base_EventLoop.continueOnNextLoop()

    @staticmethod
    def continueOnNextLoop():
        if (promhx_base_EventLoop.nextLoop is not None):
            promhx_base_EventLoop.nextLoop(promhx_base_EventLoop.f)
        else:
            promhx_base_EventLoop.f()
promhx_base_EventLoop._hx_class = promhx_base_EventLoop

class promhx_error_PromiseError(Enum):
    __slots__ = ()
    _hx_class_name = "promhx.error.PromiseError"
    _hx_constructs = ["AlreadyResolved", "DownstreamNotFullfilled"]

    @staticmethod
    def AlreadyResolved(message):
        return promhx_error_PromiseError("AlreadyResolved", 0, [message])

    @staticmethod
    def DownstreamNotFullfilled(message):
        return promhx_error_PromiseError("DownstreamNotFullfilled", 1, [message])
promhx_error_PromiseError._hx_class = promhx_error_PromiseError


class python_Boot:
    _hx_class_name = "python.Boot"
    __slots__ = ()
    _hx_statics = ["keywords", "toString1", "fields", "simpleField", "field", "getInstanceFields", "getSuperClass", "getClassFields", "prefixLength", "unhandleKeywords"]

    @staticmethod
    def toString1(o,s):
        if (o is None):
            return "null"
        if isinstance(o,str):
            return o
        if (s is None):
            s = ""
        if (len(s) >= 5):
            return "<...>"
        if isinstance(o,bool):
            if o:
                return "true"
            else:
                return "false"
        if (isinstance(o,int) and (not isinstance(o,bool))):
            return str(o)
        if isinstance(o,float):
            try:
                if (o == int(o)):
                    return str(Math.floor((o + 0.5)))
                else:
                    return str(o)
            except Exception as _hx_e:
                _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                e = _hx_e1
                return str(o)
        if isinstance(o,list):
            o1 = o
            l = len(o1)
            st = "["
            s = (("null" if s is None else s) + "\t")
            _g = 0
            _g1 = l
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                prefix = ""
                if (i > 0):
                    prefix = ","
                st = (("null" if st is None else st) + HxOverrides.stringOrNull(((("null" if prefix is None else prefix) + HxOverrides.stringOrNull(python_Boot.toString1((o1[i] if i >= 0 and i < len(o1) else None),s))))))
            st = (("null" if st is None else st) + "]")
            return st
        try:
            if hasattr(o,"toString"):
                return o.toString()
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            pass
        if (python_lib_Inspect.isfunction(o) or python_lib_Inspect.ismethod(o)):
            return "<function>"
        if hasattr(o,"__class__"):
            if isinstance(o,_hx_AnonObject):
                toStr = None
                try:
                    fields = python_Boot.fields(o)
                    _g2 = []
                    _g11 = 0
                    while (_g11 < len(fields)):
                        f = (fields[_g11] if _g11 >= 0 and _g11 < len(fields) else None)
                        _g11 = (_g11 + 1)
                        x = ((("" + ("null" if f is None else f)) + " : ") + HxOverrides.stringOrNull(python_Boot.toString1(python_Boot.simpleField(o,f),(("null" if s is None else s) + "\t"))))
                        _g2.append(x)
                    fieldsStr = _g2
                    toStr = (("{ " + HxOverrides.stringOrNull(", ".join([x1 for x1 in fieldsStr]))) + " }")
                except Exception as _hx_e:
                    _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                    e2 = _hx_e1
                    return "{ ... }"
                if (toStr is None):
                    return "{ ... }"
                else:
                    return toStr
            if isinstance(o,Enum):
                o2 = o
                l1 = len(o2.params)
                hasParams = (l1 > 0)
                if hasParams:
                    paramsStr = ""
                    _g3 = 0
                    _g12 = l1
                    while (_g3 < _g12):
                        i1 = _g3
                        _g3 = (_g3 + 1)
                        prefix1 = ""
                        if (i1 > 0):
                            prefix1 = ","
                        paramsStr = (("null" if paramsStr is None else paramsStr) + HxOverrides.stringOrNull(((("null" if prefix1 is None else prefix1) + HxOverrides.stringOrNull(python_Boot.toString1((o2.params[i1] if i1 >= 0 and i1 < len(o2.params) else None),s))))))
                    return (((HxOverrides.stringOrNull(o2.tag) + "(") + ("null" if paramsStr is None else paramsStr)) + ")")
                else:
                    return o2.tag
            if hasattr(o,"_hx_class_name"):
                if (o.__class__.__name__ != "type"):
                    fields1 = python_Boot.getInstanceFields(o)
                    _g4 = []
                    _g13 = 0
                    while (_g13 < len(fields1)):
                        f1 = (fields1[_g13] if _g13 >= 0 and _g13 < len(fields1) else None)
                        _g13 = (_g13 + 1)
                        x1 = ((("" + ("null" if f1 is None else f1)) + " : ") + HxOverrides.stringOrNull(python_Boot.toString1(python_Boot.simpleField(o,f1),(("null" if s is None else s) + "\t"))))
                        _g4.append(x1)
                    fieldsStr1 = _g4
                    toStr1 = (((HxOverrides.stringOrNull(o._hx_class_name) + "( ") + HxOverrides.stringOrNull(", ".join([x1 for x1 in fieldsStr1]))) + " )")
                    return toStr1
                else:
                    fields2 = python_Boot.getClassFields(o)
                    _g5 = []
                    _g14 = 0
                    while (_g14 < len(fields2)):
                        f2 = (fields2[_g14] if _g14 >= 0 and _g14 < len(fields2) else None)
                        _g14 = (_g14 + 1)
                        x2 = ((("" + ("null" if f2 is None else f2)) + " : ") + HxOverrides.stringOrNull(python_Boot.toString1(python_Boot.simpleField(o,f2),(("null" if s is None else s) + "\t"))))
                        _g5.append(x2)
                    fieldsStr2 = _g5
                    toStr2 = (((("#" + HxOverrides.stringOrNull(o._hx_class_name)) + "( ") + HxOverrides.stringOrNull(", ".join([x1 for x1 in fieldsStr2]))) + " )")
                    return toStr2
            if (o == str):
                return "#String"
            if (o == list):
                return "#Array"
            if callable(o):
                return "function"
            try:
                if hasattr(o,"__repr__"):
                    return o.__repr__()
            except Exception as _hx_e:
                _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                pass
            if hasattr(o,"__str__"):
                return o.__str__([])
            if hasattr(o,"__name__"):
                return o.__name__
            return "???"
        else:
            return str(o)

    @staticmethod
    def fields(o):
        a = []
        if (o is not None):
            if hasattr(o,"_hx_fields"):
                return list(o._hx_fields)
            if isinstance(o,_hx_AnonObject):
                d = o.__dict__
                keys = d.keys()
                handler = python_Boot.unhandleKeywords
                for k in keys:
                    a.append(handler(k))
            elif hasattr(o,"__dict__"):
                d1 = o.__dict__
                keys1 = d1.keys()
                for k in keys1:
                    a.append(k)
        return a

    @staticmethod
    def simpleField(o,field):
        if (field is None):
            return None
        field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
        if hasattr(o,field1):
            return getattr(o,field1)
        else:
            return None

    @staticmethod
    def field(o,field):
        if (field is None):
            return None
        if isinstance(o,str):
            field1 = field
            _hx_local_0 = len(field1)
            if (_hx_local_0 == 10):
                if (field1 == "charCodeAt"):
                    return python_internal_MethodClosure(o,HxString.charCodeAt)
                else:
                    field2 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o,field2) if (hasattr(o,field2)) else None)
            elif (_hx_local_0 == 11):
                if (field1 == "lastIndexOf"):
                    return python_internal_MethodClosure(o,HxString.lastIndexOf)
                elif (field1 == "toLowerCase"):
                    return python_internal_MethodClosure(o,HxString.toLowerCase)
                elif (field1 == "toUpperCase"):
                    return python_internal_MethodClosure(o,HxString.toUpperCase)
                else:
                    field2 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o,field2) if (hasattr(o,field2)) else None)
            elif (_hx_local_0 == 9):
                if (field1 == "substring"):
                    return python_internal_MethodClosure(o,HxString.substring)
                else:
                    field2 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o,field2) if (hasattr(o,field2)) else None)
            elif (_hx_local_0 == 5):
                if (field1 == "split"):
                    return python_internal_MethodClosure(o,HxString.split)
                else:
                    field2 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o,field2) if (hasattr(o,field2)) else None)
            elif (_hx_local_0 == 7):
                if (field1 == "indexOf"):
                    return python_internal_MethodClosure(o,HxString.indexOf)
                else:
                    field2 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o,field2) if (hasattr(o,field2)) else None)
            elif (_hx_local_0 == 8):
                if (field1 == "toString"):
                    return python_internal_MethodClosure(o,HxString.toString)
                else:
                    field2 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o,field2) if (hasattr(o,field2)) else None)
            elif (_hx_local_0 == 6):
                if (field1 == "charAt"):
                    return python_internal_MethodClosure(o,HxString.charAt)
                elif (field1 == "length"):
                    return len(o)
                elif (field1 == "substr"):
                    return python_internal_MethodClosure(o,HxString.substr)
                else:
                    field2 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o,field2) if (hasattr(o,field2)) else None)
            else:
                field2 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                return (getattr(o,field2) if (hasattr(o,field2)) else None)
        elif isinstance(o,list):
            field3 = field
            _hx_local_1 = len(field3)
            if (_hx_local_1 == 11):
                if (field3 == "lastIndexOf"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.lastIndexOf)
                else:
                    field4 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o,field4) if (hasattr(o,field4)) else None)
            elif (_hx_local_1 == 4):
                if (field3 == "copy"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.copy)
                elif (field3 == "join"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.join)
                elif (field3 == "push"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.push)
                elif (field3 == "sort"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.sort)
                else:
                    field4 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o,field4) if (hasattr(o,field4)) else None)
            elif (_hx_local_1 == 5):
                if (field3 == "shift"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.shift)
                elif (field3 == "slice"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.slice)
                else:
                    field4 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o,field4) if (hasattr(o,field4)) else None)
            elif (_hx_local_1 == 7):
                if (field3 == "indexOf"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.indexOf)
                elif (field3 == "reverse"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.reverse)
                elif (field3 == "unshift"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.unshift)
                else:
                    field4 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o,field4) if (hasattr(o,field4)) else None)
            elif (_hx_local_1 == 3):
                if (field3 == "map"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.map)
                elif (field3 == "pop"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.pop)
                else:
                    field4 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o,field4) if (hasattr(o,field4)) else None)
            elif (_hx_local_1 == 8):
                if (field3 == "iterator"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.iterator)
                elif (field3 == "toString"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.toString)
                else:
                    field4 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o,field4) if (hasattr(o,field4)) else None)
            elif (_hx_local_1 == 6):
                if (field3 == "concat"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.concat)
                elif (field3 == "filter"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.filter)
                elif (field3 == "insert"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.insert)
                elif (field3 == "length"):
                    return len(o)
                elif (field3 == "remove"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.remove)
                elif (field3 == "splice"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.splice)
                else:
                    field4 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o,field4) if (hasattr(o,field4)) else None)
            else:
                field4 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                return (getattr(o,field4) if (hasattr(o,field4)) else None)
        else:
            field5 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
            return (getattr(o,field5) if (hasattr(o,field5)) else None)

    @staticmethod
    def getInstanceFields(c):
        f = (list(c._hx_fields) if (hasattr(c,"_hx_fields")) else [])
        if hasattr(c,"_hx_methods"):
            f = (f + c._hx_methods)
        sc = python_Boot.getSuperClass(c)
        if (sc is None):
            return f
        else:
            scArr = python_Boot.getInstanceFields(sc)
            scMap = set(scArr)
            _g = 0
            while (_g < len(f)):
                f1 = (f[_g] if _g >= 0 and _g < len(f) else None)
                _g = (_g + 1)
                if (not (f1 in scMap)):
                    scArr.append(f1)
            return scArr

    @staticmethod
    def getSuperClass(c):
        if (c is None):
            return None
        try:
            if hasattr(c,"_hx_super"):
                return c._hx_super
            return None
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            pass
        return None

    @staticmethod
    def getClassFields(c):
        if hasattr(c,"_hx_statics"):
            x = c._hx_statics
            return list(x)
        else:
            return []

    @staticmethod
    def unhandleKeywords(name):
        if (HxString.substr(name,0,python_Boot.prefixLength) == "_hx_"):
            real = HxString.substr(name,python_Boot.prefixLength,None)
            if (real in python_Boot.keywords):
                return real
        return name
python_Boot._hx_class = python_Boot


class python_Lib:
    _hx_class_name = "python.Lib"
    __slots__ = ()
    _hx_statics = ["printString"]
    __name__ = None

    @staticmethod
    def printString(_hx_str):
        python_lib_Sys.stdout.buffer.write(_hx_str.encode("utf-8", "strict"))
        python_lib_Sys.stdout.flush()
python_Lib._hx_class = python_Lib


class python_internal_ArrayImpl:
    _hx_class_name = "python.internal.ArrayImpl"
    __slots__ = ()
    _hx_statics = ["concat", "copy", "iterator", "indexOf", "lastIndexOf", "join", "toString", "pop", "push", "unshift", "remove", "shift", "slice", "sort", "splice", "map", "filter", "insert", "reverse", "_get"]

    @staticmethod
    def concat(a1,a2):
        return (a1 + a2)

    @staticmethod
    def copy(x):
        return list(x)

    @staticmethod
    def iterator(x):
        return python_HaxeIterator(x.__iter__())

    @staticmethod
    def indexOf(a,x,fromIndex = None):
        _hx_len = len(a)
        l = (0 if ((fromIndex is None)) else ((_hx_len + fromIndex) if ((fromIndex < 0)) else fromIndex))
        if (l < 0):
            l = 0
        _g = l
        _g1 = _hx_len
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            if HxOverrides.eq(a[i],x):
                return i
        return -1

    @staticmethod
    def lastIndexOf(a,x,fromIndex = None):
        _hx_len = len(a)
        l = (_hx_len if ((fromIndex is None)) else (((_hx_len + fromIndex) + 1) if ((fromIndex < 0)) else (fromIndex + 1)))
        if (l > _hx_len):
            l = _hx_len
        while True:
            l = (l - 1)
            tmp = l
            if (not ((tmp > -1))):
                break
            if HxOverrides.eq(a[l],x):
                return l
        return -1

    @staticmethod
    def join(x,sep):
        return sep.join([python_Boot.toString1(x1,'') for x1 in x])

    @staticmethod
    def toString(x):
        return (("[" + HxOverrides.stringOrNull(",".join([python_Boot.toString1(x1,'') for x1 in x]))) + "]")

    @staticmethod
    def pop(x):
        if (len(x) == 0):
            return None
        else:
            return x.pop()

    @staticmethod
    def push(x,e):
        x.append(e)
        return len(x)

    @staticmethod
    def unshift(x,e):
        x.insert(0, e)

    @staticmethod
    def remove(x,e):
        try:
            x.remove(e)
            return True
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e1 = _hx_e1
            return False

    @staticmethod
    def shift(x):
        if (len(x) == 0):
            return None
        return x.pop(0)

    @staticmethod
    def slice(x,pos,end = None):
        return x[pos:end]

    @staticmethod
    def sort(x,f):
        x.sort(key= python_lib_Functools.cmp_to_key(f))

    @staticmethod
    def splice(x,pos,_hx_len):
        if (pos < 0):
            pos = (len(x) + pos)
        if (pos < 0):
            pos = 0
        res = x[pos:(pos + _hx_len)]
        del x[pos:(pos + _hx_len)]
        return res

    @staticmethod
    def map(x,f):
        return list(map(f,x))

    @staticmethod
    def filter(x,f):
        return list(filter(f,x))

    @staticmethod
    def insert(a,pos,x):
        a.insert(pos, x)

    @staticmethod
    def reverse(a):
        a.reverse()

    @staticmethod
    def _get(x,idx):
        if ((idx > -1) and ((idx < len(x)))):
            return x[idx]
        else:
            return None
python_internal_ArrayImpl._hx_class = python_internal_ArrayImpl


class _HxException(Exception):
    _hx_class_name = "_HxException"
    __slots__ = ("val",)
    _hx_fields = ["val"]
    _hx_methods = []
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = Exception


    def __init__(self,val):
        self.val = None
        message = str(val)
        super().__init__(message)
        self.val = val

_HxException._hx_class = _HxException


class HxOverrides:
    _hx_class_name = "HxOverrides"
    __slots__ = ()
    _hx_statics = ["iterator", "eq", "stringOrNull"]

    @staticmethod
    def iterator(x):
        if isinstance(x,list):
            return python_HaxeIterator(x.__iter__())
        return x.iterator()

    @staticmethod
    def eq(a,b):
        if (isinstance(a,list) or isinstance(b,list)):
            return a is b
        return (a == b)

    @staticmethod
    def stringOrNull(s):
        if (s is None):
            return "null"
        else:
            return s
HxOverrides._hx_class = HxOverrides


class python_internal_MethodClosure:
    _hx_class_name = "python.internal.MethodClosure"
    __slots__ = ("obj", "func")
    _hx_fields = ["obj", "func"]
    _hx_methods = ["__call__"]

    def __init__(self,obj,func):
        self.obj = obj
        self.func = func

    def __call__(self,*args):
        return self.func(self.obj,*args)

python_internal_MethodClosure._hx_class = python_internal_MethodClosure


class HxString:
    _hx_class_name = "HxString"
    __slots__ = ()
    _hx_statics = ["split", "charCodeAt", "charAt", "lastIndexOf", "toUpperCase", "toLowerCase", "indexOf", "toString", "substring", "substr"]

    @staticmethod
    def split(s,d):
        if (d == ""):
            return list(s)
        else:
            return s.split(d)

    @staticmethod
    def charCodeAt(s,index):
        if ((((s is None) or ((len(s) == 0))) or ((index < 0))) or ((index >= len(s)))):
            return None
        else:
            return ord(s[index])

    @staticmethod
    def charAt(s,index):
        if ((index < 0) or ((index >= len(s)))):
            return ""
        else:
            return s[index]

    @staticmethod
    def lastIndexOf(s,_hx_str,startIndex = None):
        if (startIndex is None):
            return s.rfind(_hx_str, 0, len(s))
        else:
            i = s.rfind(_hx_str, 0, (startIndex + 1))
            startLeft = (max(0,((startIndex + 1) - len(_hx_str))) if ((i == -1)) else (i + 1))
            check = s.find(_hx_str, startLeft, len(s))
            if ((check > i) and ((check <= startIndex))):
                return check
            else:
                return i

    @staticmethod
    def toUpperCase(s):
        return s.upper()

    @staticmethod
    def toLowerCase(s):
        return s.lower()

    @staticmethod
    def indexOf(s,_hx_str,startIndex = None):
        if (startIndex is None):
            return s.find(_hx_str)
        else:
            return s.find(_hx_str, startIndex)

    @staticmethod
    def toString(s):
        return s

    @staticmethod
    def substring(s,startIndex,endIndex = None):
        if (startIndex < 0):
            startIndex = 0
        if (endIndex is None):
            return s[startIndex:]
        else:
            if (endIndex < 0):
                endIndex = 0
            if (endIndex < startIndex):
                return s[endIndex:startIndex]
            else:
                return s[startIndex:endIndex]

    @staticmethod
    def substr(s,startIndex,_hx_len = None):
        if (_hx_len is None):
            return s[startIndex:]
        else:
            if (_hx_len == 0):
                return ""
            if (startIndex < 0):
                startIndex = (len(s) + startIndex)
                if (startIndex < 0):
                    startIndex = 0
            return s[startIndex:(startIndex + _hx_len)]
HxString._hx_class = HxString

Math.NEGATIVE_INFINITY = float("-inf")
Math.POSITIVE_INFINITY = float("inf")
Math.NaN = float("nan")
Math.PI = python_lib_Math.pi

buddy_BuddySuite.useDefaultTrace = False
haxe_EntryPoint.pending = list()
haxe_EntryPoint.threadCount = 0
logipar_Token.AND = "AND"
logipar_Token.OR = "OR"
logipar_Token.XOR = "XOR"
logipar_Token.NOT = "NOT"
logipar_Token.OPEN = "OPEN"
logipar_Token.CLOSE = "CLOSE"
logipar_Token.LITERAL = "LITERAL"
promhx_base_EventLoop.queue = haxe_ds_List()
python_Boot.keywords = set(["and", "del", "from", "not", "with", "as", "elif", "global", "or", "yield", "assert", "else", "if", "pass", "None", "break", "except", "import", "raise", "True", "class", "exec", "in", "return", "False", "continue", "finally", "is", "try", "def", "for", "lambda", "while"])
python_Boot.prefixLength = len("_hx_")

Test.main()
haxe_EntryPoint.run()
